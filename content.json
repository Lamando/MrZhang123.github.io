{"meta":{"title":"MrZhang's Blog","subtitle":"Grow up every day","description":"front-end developer Website","author":"ZhangYi","url":"http://mrzhang123.github.io"},"pages":[{"title":"","date":"2016-10-08T14:29:35.779Z","updated":"2016-10-08T14:29:35.779Z","comments":true,"path":"about/index.html","permalink":"http://mrzhang123.github.io/about/index.html","excerpt":"","text":"我是张毅，1991年生于山西，毕业于山西大学计算机科学与技术专业。目前就职于北京小米科技有限公司，擅长前端，是个技术控，关注科技类的东西。喜欢尝试一些新的东西，希望可以成为一个文艺的程序员。喜欢自己折腾一些东西，软件硬件都可以，喜欢动手做一些有趣的东西。"},{"title":"categories","date":"2016-03-25T15:19:18.000Z","updated":"2016-03-25T17:13:32.080Z","comments":false,"path":"categories/index.html","permalink":"http://mrzhang123.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Git连接Github总结","slug":"gitandgithub","date":"2016-11-13T02:54:26.000Z","updated":"2016-11-13T03:12:56.000Z","comments":true,"path":"2016/11/13/gitandgithub/","link":"","permalink":"http://mrzhang123.github.io/2016/11/13/gitandgithub/","excerpt":"好长时间不写东西了， 因为换了工作，所以在忙着熟悉公司的项目代码，所以没什么时间搞自己的东西，回想了一下，在计划中要总结一下关于如何使用终端的git连接github，所以写一下这个。","text":"好长时间不写东西了， 因为换了工作，所以在忙着熟悉公司的项目代码，所以没什么时间搞自己的东西，回想了一下，在计划中要总结一下关于如何使用终端的git连接github，所以写一下这个。 创建github仓库在注册了账号后登陆点击头像旁边的+选择New repository创建一个个人的仓库。填写仓库名称，如图所示： 安装git客户端如果是windows，建议安装gitbash 如果是mac，先安装Homebrew，然后再使用homebrew安装git。 1$ brew install git 如果是linux直接在终端使用apt-get安装： 1sudo apt-get install git 配置git1.初始化git一般我们是要将自己的本地项目上传到github，实现开源共享，那么就首先需要让git知道它需要跟踪这个项目，所以，我们首先在终端进入项目，初始化git(以mac为例，假设项目在桌面)： 1234567//进入项目$ cd Desktop/myproject//初始化git$ git init 2.创建ssh key为了让github能够识别是我们自己上传文件，需要创建ssh key 1$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 这里的your_email@youremail.com是你的邮箱地址，在输入后会询问你是否保存创建的ssh key，点回车就好，然后要求输入你要设置的密码，如果直接回车表示不设密码。然后会提示你ssh key已经创建好。 3.将ssh可以写入github创建好本地的ssh key后，我们需要让github知道这个ssh key是我们自己，所以需要将生成的ssh key复制出来，写入github，在mac下在终端输入 1cat ~/.ssh/id_rsa.pub 此时在终端会显示出刚刚创建好的ssh key，复制出来，在github在点击头像，然后点击setting，在找到SSH and GPG keys，创建一个new ssh key，然后将刚刚复制的ssh key填入即可。 4.验证是否连接成功在终端输入 1$ ssh -T git@github.com 如果回车看到：You’ve successfully authenticated, but GitHub does not provide shell access 。表示已成功连上github。 5.设置username和email在把本项目上传到github之前还需要分别输入设置username和email，因为github每次commit都会记录他们。所以分别输入如下命令： 12$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your_email@youremail.com&quot; 6.添加远程地址在与github连接成功后，如何才能让相应的项目上传到对应的仓库呢？这里就需要添加远程地址，从而让我们的本地项目顺利到达对应的仓库。 打开终端，输入 1$ git remote add origin git@github.com:yourName/yourRepo.git 后面的yourName和yourRepo分别是你的github的用户名和刚才新建的仓库名。 上传项目进入项目，在终端运行 1$ git status 查看要上传的文件是否正确，然后将项目下的所有文件添加到git跟踪范围。 1$ git add . 记录此次提交并上传 12$ git commit -m &apos;my project push&apos;$ git push origin master 这里的master指的是主分支名，如果是其他分支，则填写相应的分支名。 这样我们就将我们的项目上传到github仓库。","categories":[{"name":"git&github","slug":"git-github","permalink":"http://mrzhang123.github.io/categories/git-github/"}],"tags":[{"name":"git&github","slug":"git-github","permalink":"http://mrzhang123.github.io/tags/git-github/"}],"keywords":[{"name":"git&github","slug":"git-github","permalink":"http://mrzhang123.github.io/categories/git-github/"}]},{"title":"Linux日常使用总结","slug":"linux-study","date":"2016-10-02T15:33:47.000Z","updated":"2016-10-08T14:26:38.074Z","comments":true,"path":"2016/10/02/linux-study/","link":"","permalink":"http://mrzhang123.github.io/2016/10/02/linux-study/","excerpt":"自己一直对linux充满好奇，这次换了新的工作后，由于使用Mac OS和linux，所以国庆回来，给自己的电脑装了ubuntu来熟悉linux。在安装完成后遇到一些问题，经过谷歌都一一解决了，写这篇博文分享给大家。","text":"自己一直对linux充满好奇，这次换了新的工作后，由于使用Mac OS和linux，所以国庆回来，给自己的电脑装了ubuntu来熟悉linux。在安装完成后遇到一些问题，经过谷歌都一一解决了，写这篇博文分享给大家。 1．设置获取root权限1sudo passwd root //设置root密码 然后输入当前系统账户的密码并设置新的UNIX密码，密码更新成功后在终端输入su然后输入刚刚设置好的新的UNIX密码，即可进入root权限，如果想退出，输入exit。 ２．在linux下如何安装shadowsocks因为自己是搞开发的，而且非常喜欢谷歌，所以就需要一个自由的网络环境，博主用的是shadowsocks，在windows下，有客户端，但是现在装了linux，既然装了linux，能用命令行搞定的就尽量用命令行，所以我选择在终端安装shadowsocks客户端，步骤如下： 安装shadowsocks客户端123sudo apt-get update sudo apt-get install python-gevent python-pippip install shadowsocks 建立配置文件打开终端，运行vim /etc/ss.json，然后写入json 123456789&#123; \"server\" : \"you server\", \"server_port\" : 0000, \"local_address\" : \"127.0.0.1\", \"local_port\" : 1080, \"password\" : \"you password\", \"method\" : \"aes-256-cfb\", //shadowsocks的加密方式 \"fast_open\" : false&#125; 开启shadowsocks12345sslocal -c /etc/ss.json// 开启后显示以下内容，代表开启成功：// INFO loading libcrypto from libcrypto.so.1.0.0// INFO starting local at 127.0.0.1:1080 设置开机启动1234// 打开图形化开机启动项管理界面gnome-session-properties// 添加(Add) -&gt; 名称(name)和描述(comment)随便填，命令(Command)填写如下： sslocal -c /etc/ss.json 火狐浏览器配置设置→首选项→高级→网络→链接→设置→手动配置代理→socks主机：127.0.0.1 端口：1080→确定 chrome配置在终端中输入如下命令： 1chromium-browser --proxy-server=socks5://127.0.0.1:1080 进入后安装SwitchyOmega，然后配置此插件： 情景模式→删除原有的情景模式，新建情景模式（原有的情景模式无socks代理）→手动配置→SOCKS代理：127.0.0.1 端口1080→保存 →ok note:我在这里运行这个命令后依然无法进入，不清楚是怎么回事儿，所以我直接找了个host进行了替换，关于host，我推荐老d博客中提供的，具体用法他博客中有写。然后才进入的应用商店下载好。 ３．安装相应的软件安装Gdebi软件包安装程序在ubuntu中有自己的软件中心，但是有些软件在里面找不到，需要自己去官网下载客户端然后安装（比如网易云音乐，搜狗拼音等），下载好的安装包大部分都是.deb文件，查阅了需要资料，安装这个用gdebi比较方便，在软件中心搜索Gdebi软件包安装程序安装就好，但是，既然用linux了，就用一下它强大的终端，所以我说一下在终端如何安装 在终端输入 1sudo apt-get install gdebi 但是我在这里输入后，提示我缺少相应的依赖，并让我运行 1sudo apt-get install -f 运行完成这个命令后，相应的依赖就被安装好了，这里的这个命令主要是修复依赖关系（depends）的命令，之后重新运行sudo apt-get install gdebi即可。 安装对应的软件在安装完成这个后，安装软件就方便很多，我比如安装chrome浏览器，直接进入下载好文件的目录，运行 1sudo gdebi chrome.deb //这里是你要安装包的名字 完成后去搜索即可。在安装时候我发现有的软件在安装完成后需要重启下电脑才会有。 卸载apt-get安装的东西有时候需要卸载一些apt-get安装的东西，需要命令为 1sudo apt-get remove XXX //XXX为要卸载的东西 安装node做前端开发，node是必不可少的，所以需要安装一下，在windows下都是直接下载安装包安装，我本来也在linux下下了个安装包安装了，但是查了一下发现用nvm安装node的比较多，而且那天在公司老大也说在mac下推荐使用nvm安装，所以自己决定试下。 1.安装 nvm 之后最好先删除下已安装的 node 和全局 node 模块：1234npm ls -g --depth=0 //查看已经安装在全局的模块，以便删除这些全局模块后再按照不同的 node 版本重新进行全局安装sudo rm -rf /usr/local/lib/node_modules //删除全局 node_modules 目录sudo rm /usr/local/bin/node //删除 nodecd /usr/local/bin &amp;&amp; ls -l | grep \"../lib/node_modules/\" | awk '&#123;print $9&#125;'| xargs rm //删除全局 node 模块注册的软链 话说最后一条命令运行会报rm使用错误，不知道怎么弄… 2.安装nvm运行以下两条命令之一 123curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.0/install.sh | bash//orwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.32.0/install.sh | bash 然后进入(~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc)这些文件，看哪个文件有，在最后一行添加. 12export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; . \"$NVM_DIR/nvm.sh\" # This loads nvm 这里如果不太会改这个的话，可以设置终端从而达到效果，在终端打开编辑→配置文件首选项→命令中勾选以登录shell方式运行命令。在ubuntu中没有执行命令时更新登录登录记录，如果有，一起勾选，然后在终端输入 1nvm 即可看到帮助，之后运行 1nvm install node 就可以安装到最新版本的node，更多关于nvm的用法可参考node版本管理工具nvm-Mac下安装及使用 至此，linux下常用的软件就安装完成…","categories":[{"name":"linux","slug":"linux","permalink":"http://mrzhang123.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://mrzhang123.github.io/tags/linux/"}],"keywords":[{"name":"linux","slug":"linux","permalink":"http://mrzhang123.github.io/categories/linux/"}]},{"title":"北京的这一年，写在离开的这一天","slug":"thoughts","date":"2016-09-24T01:41:09.000Z","updated":"2016-10-02T02:21:44.815Z","comments":true,"path":"2016/09/24/thoughts/","link":"","permalink":"http://mrzhang123.github.io/2016/09/24/thoughts/","excerpt":"2016年9月23日，对于我来说是一个特殊的日子，我离开了我工作一年多的公司，这是我第一家公司，我的职业之路起于这里，这里是我起飞的地方。","text":"2016年9月23日，对于我来说是一个特殊的日子，我离开了我工作一年多的公司，这是我第一家公司，我的职业之路起于这里，这里是我起飞的地方。 初到北京求职&emsp;&emsp;2015年9月，我离开家乡，和同学一起踏上从太原去往北京的火车。对于北京，我并不陌生，之前来过几次玩儿，但是这次与以往不同，这次我要去梦想之地去实现自身的价值，所以心里还是蛮激动的，对于以后在北京的生活也充满了期待。三个小时后，我们到达了北京，九月初的北京温度还没有降下来，下车后，那种熟悉的感觉迎面而来，我又回到了我熟悉的地方—北京。 &emsp;&emsp;到达北京后的第一件事是找住的地方，因为每个人并不知道要去哪儿工作，所以我们需要先找个临时住所，那时候我在北京认识的人很少，幸亏有同学认识人，帮我们找了一个比较便宜的住的地方，我记得那时候在去住的地方的路上越走越懵逼，给我的感觉是我们刚到北京就要出北京市，经过几次换乘公交车，我们到达了我们要住的地方—老牛湾，熟悉北京的朋友应该知道那里是什么情况，当时到达那个地方后的第一反应是，这里是北京么？？这…我姥姥村都比这个强啊，后来想想北京的房价很高，而我们又是临时住，这里对于我们来说，是最合适的。 &emsp;&emsp;安顿好的第二天，我们各自开始踏上求职之路，因为之前在太原就投过很多公司，所以面试也不少，来到北京后直接可以找公司面试了。因为我们住的地方离北京市确实远，所以我们每天早晨7点起来开始各自准备准备出发，先坐公交到昌平线，然后再做地铁进入北京市。第一次在昌平线坐车的时候吓死我了，人多到爆，上车时候都不用自己动，人流会把你推上去的，这让我第一次见识到北京上班的高峰期！ &emsp;&emsp;可能是初生牛犊不怕虎吧（其实本身也没什么），第一次面试，我去了58同城，见识到了真正的前端面试，至今让我记忆尤新。我到了地方，坐着58的班车，到达曾经在互联网上见过无数次的公司，经过一番面试，面试官给了我一句话：“不好意思，我们需要的是一个能独揽一条产品线的人，你并不合适。”其实这句话并没有打击到我，因为于我来讲，我知道自己的水平在哪儿，来学习一些面试的东西也是值得的，所以也觉得无所谓。在之后的面试中，去的都是一些创业公司，面试的问的东西也是各式各样，因为有58同城的参考，所以时至今日，我都觉得他们的那些面试真的很不专业。从周一开始找工作，找到周五，别的同学都有了相应的offer，但是我自己却一个没有，那时候确实自己有点儿慌了，感觉压力也越来越大。在这五天内，我听到最多的，也是至今最烦的一句话：“等通知吧”…直到周五下午。 &emsp;&emsp;周五的下午，我来到我接下来供职一年多的公司面试，其实那时候我并没有投，是hr主动联系我让我去面试，那时候想，既然让去那就去吧。可能是一个offer都没有吧，很失望，所以那时候去公司面试并没有报太大希望，当时到了公司后，给我的感觉是，这个公司似乎很沉闷（事实上我后来发现我完全错了）。进去之后首先是填了张表，然后就开始面试，我老大并没有问我太多的前端的问题，只是简单的聊了聊，就把我要了（后来他说那时候觉得我比较踏实，所以就要了。），然后hr进来跟我聊了聊薪资什么的，最后走的时候送我一瓶饮料，嘿嘿。这次面试之后，我决定直接在这里入职了，不再面了，因为每天面试成本太高了。 职业生涯的开始&emsp;&emsp;2015年9月16日，我来到公司报到，开始了自己人生新的篇章。那时候我们还在老牛湾住，而公司在北京的南边，所以我每天上班先坐公交后坐地铁，每天上班两小时，下班两小时，现在想想也是相当可以了，哈哈。差不多我在公司上班一周后，我们开始找自己各自的住处，一部分在北京的北边，另一部分来到了南边。安顿好住处后，我开始了属于自己的职场生活。 &emsp;&emsp;刚去公司每天就是学习一些东西，后来开始做一些项目。记得刚去的时候我开始做的是整个公司网站的一个改版，大部分都更改，这算是一个比较大的工程吧，因为刚开始工作吧，对于团队协作什么的仅仅停留在概念上，所以在合作的时候时不时的出一些问题，有几次犯的错比较都被创始人说了，幸运的是我遇到一个好的老大，有什么事儿都帮我说话，所以我并没有什么事儿。记得有一次因为更改了php文件中的几个参数导致推广页面无法使用，连累我老大被CEO说，具体怎么说他的我不清楚，他只是跟我说：“没事儿，谁都会犯错，我那时候工作也犯过错误，改正就好。”从那时起我下定决心一定要把工作做好，要对得起我老大。 &emsp;&emsp;在忙碌的工作中，我度过了2015年，这半年，公司的人数涨了很多，同时在大家的共同努力下，公司从天使轮走到了A轮。不知不觉中，来到公司的年会，年会上，很多人喝的很嗨，因为自己并不爱喝酒，所以并没有喝趴下，哈哈。年会上，CEO总结了一下公司这一年来的发展，并说在明年年会上，公司的人数要翻一番。那时候开始觉得公司是非常有前途。但是在第二年的开春开始上班的时候，我发现和我一批来的就剩下我和我哥们儿了，大部分都离开了公司（包括招我进来的hr），至于什么原因就不说了，直到现在有时候还会怀念他们，如果不是公司的hr，我也没机会来这里上班。 失望，离开&emsp;&emsp;由于在公司工作并不是很忙，所以我有机会可以学习一些新的东西，这让我自己的技术在这一年中有了一定的提高，这一点上我非常感激公司。但是后来我发现我学到这些东西后，我不知道我该怎么用到公司的项目中，其实我自己在后来有跟公司提过，同时公司还让我分享过一些我自己学到的东西，曾经想过试着凭借自己学到的东西帮助公司在前端开发方面效率提上去，但是后来我发现，仅限于此，自己提出的一些东西公司领导会考虑一下，然后…就没有然后了… &emsp;&emsp;在公司经历了一年，渐渐的发现，也许自己并不适合这里，所以经过一些面试后，自己找到了自己合适的工作，在2016年9月19日，我在QQ上跟我老大说我想离职，我老大并没有说什么，只是问我找到工作了么，我告诉他我找到了，之后问了一些关于手续的事儿，就这样，我在9月23日下午，我办完所有的交接，拿着离职证明，离开了我工作一年的公司。 &emsp;&emsp;对于离开这里，我并没有不舍，因为我深知自己并不适合这里，只是有时候觉得对不起我老大，虽然他在前端技术方面不是很让我折服，但是这一年来，他对我的照顾我还是非常感激的，最后跟他说我要离职，他问我找好下家了么的时候我知道，其实他早知道我要走了，可能就在等我这句话吧。我记得有一次我有点儿不舒服，请假回家，他还非常关心的问我怎么回事儿，不行就去医院看看，买点儿药，公司可以报销。真的非常感激他，虽然我们之间的对话大部分都是关于工作的事儿… &emsp;&emsp;对于我自己来说，我其实并不喜欢经常跳槽，因为在一个公司待久了会有自己熟悉的人，有自己喜欢干的事儿，会对自己的公司产生一种感情，但是这些都是建立在工作非常开心，融入公司的环境的情况下。在公司的时间长了，渐渐的明白，公司的文化如同一个漏斗，会筛选出一批相似的人。 写在最后&emsp;&emsp;虽然我离开了，但是我一直都觉得公司很有前途，在我走的时候，公司已经从我当初刚去的20多人发展成70多人了，我感到很欣慰。同时，希望公司可以招到更好的前端，可以在未来发展的更好。","categories":[{"name":"感想","slug":"感想","permalink":"http://mrzhang123.github.io/categories/感想/"}],"tags":[{"name":"感想","slug":"感想","permalink":"http://mrzhang123.github.io/tags/感想/"}],"keywords":[{"name":"感想","slug":"感想","permalink":"http://mrzhang123.github.io/categories/感想/"}]},{"title":"基于Gulp的前端自动化工程搭建","slug":"gulpUse","date":"2016-09-07T15:25:06.000Z","updated":"2016-09-07T16:06:09.466Z","comments":true,"path":"2016/09/07/gulpUse/","link":"","permalink":"http://mrzhang123.github.io/2016/09/07/gulpUse/","excerpt":"上个月月底在公司提出关于前后端分离的想法，并且开始研究关于前后端分离，前端工程化，模块化的一些东西，上周开始我准备自己开始写基于Gulp流的前端工程文件，这两天有时间，着手开始实现这个想法，但是写的过程中，遇到了一些问题，正是因为这些问题的解决让我对Gulp的流式处理有了更深的理解，写下这篇文章，分享一下这俩天我在写Gulp的时候学到的一些东西。","text":"上个月月底在公司提出关于前后端分离的想法，并且开始研究关于前后端分离，前端工程化，模块化的一些东西，上周开始我准备自己开始写基于Gulp流的前端工程文件，这两天有时间，着手开始实现这个想法，但是写的过程中，遇到了一些问题，正是因为这些问题的解决让我对Gulp的流式处理有了更深的理解，写下这篇文章，分享一下这俩天我在写Gulp的时候学到的一些东西。 准备工作安装Node首先Gulp是基于Nodejs的，所以安装Nodejs是前提，Node可以说是前端神器，基于Node有各种各样的工具，正是因为这些工具让我们非常方便的构建前端工程。 更改Node插件默认安装位置（非必需）我自己一般不喜欢在C盘状太多与系统无关的东西，而通过Node自带的npm安装的插件默认在C盘，但是我将Node安装到D盘后，想让插件就安装在Nodejs的主目录下，怎么办呢？ 在Node主目录下新建”node_global”及”node_cache”两个文件夹 启动cmd，输入 123//后面的设置目录根据你的目录结构自行更改npm config set prefix \"D:\\Program\\nodejs\\node_global\"npm config set cache \"D:\\Program\\nodejs\\node_cache\" 关闭cmd，打开系统对话框，“我的电脑”右键“属性”-“高级系统设置”-“高级”-“环境变量”。 进入环境变量对话框，在系统变量下新建”NODE_PATH”，输入”D:\\Program\\nodejs\\node_global\\node_module”。 由于改变了module的默认地址，所以上面的用户变量都要跟着改变一下（用户变量”PATH”修改为”D:\\Program\\nodejs\\node_global\\”），要不使用module的时候会导致输入命令出现“xxx不是内部或外部命令，也不是可运行的程序或批处理文件”这个错误。 经过这四步的设置就可以让安装的Node插件放在Nodejs的主目录了。 安装Gulp1234//全局安装Gulpnpm install -g gulp//在项目中安装Gulpnpm install --save-dev gulp 运行gulp -v,如果不报错，表示安装成功 然后在命令行运行 1npm init 让项目生产package.json文件 搭建工程众所周知，在开发工程中有开发和上线两个过程，在开发中，我们一般需要自动刷新以及实时编译，但是如果上线，我们就需要考虑很多优化的东西，比如文件编译压缩，静态资源放缓存处理等等问题，我自己搭的这个工程只涉及到文件编译压缩，实时刷新，静态资源放缓存这三个基本的流程。 在项目的目录结构如下 1234567891011121314151617181920212223242526-------------------project | |--------------dist (该文件夹为打包生成的) | | | |----------css | | | | | |------index-9dcc24fe2e.css | | | |----------js | | | | | |------index-9dcc24fe2e.js | |----------index.html | |--------------src | | | |----------scss | | | | | |------index.scss | | | |----------js | | | | | |------index.js | | | |----------index.html |--------------gulpfile.js |--------------package.json 开发所用流程文件编译在工程中准备使用scss作为css的预编译，所以需要利用gulp对scss进行编译，所以首先安装gulp-sass。 1npm install --save-dev gulp-sass 安装完成之后，直接在gulpfile.js引用配置 1234567const sass = require('gulp-sass'); //scss编译gulp.task('scss:dev',()=&gt;&#123; gulp.src('src/scss/*.scss') .pipe(sass()) .pipe(gulp.dest('dist/css')); //将生成好的css文件放到dist/css文件夹下&#125;); 这里简单介绍下gulp的两个api： gulp.src()输入符合所提供的匹配模式或者匹配模式的数组的文件。将返回一个stream或者可以被piped到别的插件中。读文件 gulp.dest()能被pipe进来，并且将会写文件。并重新输出（emits）所有数据，因此可以将它pipe到多个文件夹，如果文件夹不存在则将会自动创建。写文件 实时刷新实现实时刷新的工具有很多，我自己使用browser-sync，这个工具的功能非常强大，想了解它更多的用法可以查看官网：http://www.browsersync.cn/。 首先我们在项目中安装该模块 1npm install --save-dev browser-sync 根据官网的browser-sync与gulp的配置，得到如下配置： 1234567891011121314151617const browserSync = require('browser-sync').create(); //实时刷新const reload = browserSync.reload;gulp.task('dev',['scss:dev'],function () &#123; browserSync.init(&#123; server:&#123; baseDir:'./' //设置服务器的根目录 &#125;, logLevel: \"debug\", logPrefix:\"dev\", browser:'chrome', notify:false //开启静默模式 &#125;); //使用gulp的监听功能，实现编译修改过后的文件 gulp.watch('src/scss/*.scss',['scss:dev']); gulp.watch(('*.html')).on('change',reload);&#125;); 这样，一个简单的gulp开发流程就出来了，仅仅只是一个编译scss和一个实时刷新。 打包上线所有流程打包上线，我们更多的是考虑，静态资源防缓存，优化。对css，js的压缩，对图片的处理，我写的这个简单的流程中并没有涉及对图片的处理，所以这里仅针对css，js，html处理。 压缩css我们使用gulp-sass就可以，因为它在编译scss的时候有一个配置选项可以直接输出被压缩的css。压缩js我使用了gulp-uglify，静态资源防缓存使用gulp-rev和gulp-rev-collector。 对css，js的处理1234567891011121314151617181920//scss编译gulp.task('css',()=&gt; &#123; gulp.src('src/scss/*.scss') .pipe(sass(&#123; outputStyle: 'compressed' //编译并输出压缩过的文件 &#125;)) .pipe(rev()) //给css添加哈希值 .pipe(gulp.dest('dist/css')) .pipe(rev.manifest()) //给添加哈希值的文件添加到清单中 .pipe(gulp.dest('rev/css'));&#125;);//压缩jsgulp.task('js', ()=&gt; &#123; gulp.src('src/js/*js') .pipe(uglify()) .pipe(rev()) //给js添加哈希值 .pipe(gulp.dest('dist/js')) .pipe(rev.manifest()) //给添加哈希值的文件添加到清单中 .pipe(gulp.dest('rev/js'));&#125;); 其中gulp-rev是为css文件名添加哈希值，而rev.manifest()会生成一个json文件，这个json文件中记录了原文件名和添加哈希值后的文件名的一个对应关系，这个对应关系在最后对应替换html的引用的时候会用到。 生成的json文件如下： 123&#123; \"index.css\": \"index-9dcc24fe2e.css\"&#125; 由于给文件添加了哈希值，所以每次编译出来的css和js都是不一样的，这会导致有很多冗余文件，所以我们可以每次在生成文件之前，先将原来的文件全部清空。 gulp中也有做这个工作的插件—gulp-clean，因此我们可以在编译压缩添加哈希值之前先将原文将清空。 清空生成的项目文件123456const clean = require('gulp-clean'); //清空文件夹里所有的文件//每次打包时先清空原有的文件夹gulp.task('clean', ()=&gt; &#123; gulp.src(['dist', 'rev'], &#123;read: false&#125;) //这里设置的dist表示删除dist文件夹及其下所有文件 .pipe(clean());&#125;); 让添加哈希编码的文件自动添加到html中前面提到的gulp-rev实现了给文件名添加哈希编码，但是在打包完成后如何让原来未添加哈希值的引用自动变为已经添加哈希值的引用，这里用到gulp-rev的一个插件gulp-rev-collector，配置如下： 123456789101112//将处理过的css，js引入htmlgulp.task('reCollector',()=&gt;&#123; gulp.src(['rev/**/*.json','src/*.html']) .pipe(reCollector(&#123; replaceReved: true, //模板中已经被替换的文件是否还能再被替换,默认是false dirReplacements: &#123; //标识目录替换的集合, 因为gulp-rev创建的manifest文件不包含任何目录信息, 'css/': '/dist/css/', 'js/': '/dist/js/' &#125; &#125;)) .pipe(gulp.dest('dist'))&#125;); 并没有正常替换？在我自己写的时候，出现这个问题，运行完成该任务后，html中的css和js引用并没有发生变化，网上搜了半天，才知道是由于自己用了gulp-rename插件，然后将文件名都添加了.min（至于为什么添加，仅仅是因为是压缩过的，应该写个）而在自己写的html里面引用的文件并没有.min，由于gulp-rev-collector在替换的时候根据生成的json文件替换，在json中，文件都有了.min而在html中没有，所以无法匹配，自然也就不能实现替换了，所以在替换的时候一定要注意gulp-rev生成的json文件中的css，js与html中的引用的一样，否则无法实现替换。 在gulp-rev-collector的api中有一个revSuffix，这个看起来可以实现类似于gulp-rename的功能，但是不知道该怎么用，大家如果知道的话请告诉我… 执行所有任务完成上面几个步骤后我们将所有任务串起来，让其可以一条命令然后全部执行 1gulp.task('build',['clean', 'css', 'js', 'reCollector']); 再次理解gulpgulp—它的task是顺序执行吗？本以为到这里，就算是写完了，运行，完美，打包生成文件，再运行一次，报错了！！！！ 1234567[19:04:57] Finished 'default' after 7.38 μsstream.js:74 throw er; // Unhandled stream error in pipe. ^Error: ENOENT: no such file or directory, stat 'D:\\project\\dist\\js\\index-6045b384e6.min.js' at Error (native) 提示我找不到这个文件，这让我很郁闷啊，然后我分开执行，很ok，可以确定是执行顺序有问题，很可能在没有清理完成就执行后面了，查了gulp的官网文档才知道本身gulp的pipe是一个一个任务进行的，是同步的，但是每个task之间是不同步的，是一起进行的，这也验证了我的猜想，所以在网上找如何解决这个问题，找到一个叫run-sequence的npm插件，配置文件如下： 1234//进行打包上线gulp.task('build', ()=&gt; &#123; runSequence('clean', ['css', 'js'], 'reCollector');&#125;); 本以为运行就ok，结果，还是报错，这里就涉及到对gulp的另一个理解 run-sequence插件对异步任务的处理在用这个插件让任务有序进行后，我想进一步直观的看到它对任务的序列化，自己写了一个demo，如下： 1234567891011gulp.task('a',function()&#123; setTimeout(function () &#123; console.log(1); &#125;,30);&#125;);gulp.task('b',function() &#123; console.log(2);&#125;);gulp.task('ab',function()&#123; runSequence('a','b');&#125;); 但是这里就出现问题了，runSequence不管用了，找插件的说明和gulp官方文档，原来异步任务，像setTimeout，readFile等，需要添加一个callback的执行，这里的callback()就会返回一个promise的resolve()，告诉后面的任务，当前任务已经完成，后面可以继续执行了，所以在task a里面执行callback。 123456gulp.task('a',function(cb)&#123; setTimeout(function () &#123; console.log(1); cb(); &#125;,30);&#125;); 那为什么前面写的那些任务不需要添加一个callback呢？由于gulp的pipe流让每一个task中的小任务（每一个pipe）顺序执行，从而整个pipe流是同步的，并不是异步任务，所以并不需要手动让其返回promise，run-sequence会自动帮我们管理。 gulpfile的分离在前面我们将dev和build写在了一个叫gulpfile的文件中，虽然可以执行，但是当我们的工程越来越大的时候，会导致gulpfile可维护性降低，那能否让dev和build分别写在两个文件中呢？答案是可以的，我们可以新建两个文件，分别为gulpfile-dev.js和gulpfile-build.js，其实我们在运行gulp build的时候，其实是运行了gulp –gulpfile gulpfile.js build，前者相当于后者的缩写，所以在运行gulp的时候在命令中输入如下： 123gulp --gulpfile gulpfile-dev.jsgulp --gulpfile gulpfile-build.js 就可以在gulp运行时候指定gulpfile。这样我们再原来的task中的buil和dev改成default就可以直接运行以上命令达到预期效果。 但是每次敲这么长的命令很烦，怎么办呢？我们可以在package.json的scripts中添加如下json： 12\"dev\": \"gulp --gulpfile gulpfile-dev.js\"\"build\": \"gulp --gulpfile gulpfile-build.js\" 这样，我们在运行的时候，直接在命令行输入： 12npm run devnpm run build 就可以实现打包了，是不是很酸爽，哈哈！ 总结至此，我们就完成了一个简易的基于gulp的前端工程的搭建，很多东西确实，想着并不难，做起来会出现各种各样意想不到的问题，gulp很早就知道，都是单个任务在写，然后用哪个执行哪个命令，直到自己写完这个这个简单的工程，才对gulp有了更深入的理解。","categories":[{"name":"Javascript Gulp Nodejs","slug":"Javascript-Gulp-Nodejs","permalink":"http://mrzhang123.github.io/categories/Javascript-Gulp-Nodejs/"}],"tags":[{"name":"Javascript Gulp Nodejs","slug":"Javascript-Gulp-Nodejs","permalink":"http://mrzhang123.github.io/tags/Javascript-Gulp-Nodejs/"}],"keywords":[{"name":"Javascript Gulp Nodejs","slug":"Javascript-Gulp-Nodejs","permalink":"http://mrzhang123.github.io/categories/Javascript-Gulp-Nodejs/"}]},{"title":"CSS3实现翻转卡牌效果","slug":"FlipCards","date":"2016-08-17T15:35:52.000Z","updated":"2016-08-17T15:39:19.227Z","comments":true,"path":"2016/08/17/FlipCards/","link":"","permalink":"http://mrzhang123.github.io/2016/08/17/FlipCards/","excerpt":"今天在工作中遇到需求，需要用CSS3写一个卡片翻转效果，这个效果看起来简单，但是还是涉及到一些不常用的CSS3中的3D转换的属性以及实现该效果的思路，所以这里总结一下。 项目地址：https://github.com/MrZhang123/Practice/tree/master/FlipCards","text":"今天在工作中遇到需求，需要用CSS3写一个卡片翻转效果，这个效果看起来简单，但是还是涉及到一些不常用的CSS3中的3D转换的属性以及实现该效果的思路，所以这里总结一下。 项目地址：https://github.com/MrZhang123/Practice/tree/master/FlipCards 需要的CSS3属性perspective目前浏览器都不支持perspective属性 在chrome和Safari中需要使用-webkit-perspective，而在Firefox中需要使用-moz-perspective来定义。 定义和用法perspective属性定义3D元素距视图的距离，以像素计。该属性允许改变查看3D元素的视图。当为元素定义 perspective属时，其子元素会获得透视效果，而不是元素本身。换句话说，设置这个元素是为了给该元素的子元素用。 值number：元素距离视图的距离，以像素计 none：默认值，与0相同。不设置透视 transform-styleFirefox支持transfrom-style属性。 Chrome、Safari和Opera支持代替的-webkit-transform-style属性。 定义和用法transform-style属性固定如何在3D空间中呈现被嵌套的元素。一般给父元素设置让其所有子元素跟着父元素一起位置移动，一般会设置。 值flat：子元素将不保留其3D位置（默认值） perserve-3d：子元素将保留其3D位置 transitionIE10+、Firefox、Opera、Chrome均支持transition属性。Safari支持替代的-webkit-transition属性。但是IE9-不支持该属性。 定义和用法transition属性是一个简写属性，用于设置四个过渡属性： transiton-property：规定设置过渡效果的CSS属性的名称 transiton-duration：规定完成过渡效果需要多少秒或毫秒 transiton-timing-funciton：规定速度效果的速度曲线 transition-delay：规定过渡效果何时开始 transiton-duration必须设置，否则时长为0 ，不会有过渡效果 backface-visibility只有IE10+和Firefox支持backface-visibility，Opera15+、Safari和Chrome支持替代的-webkit-backface-visibility 定义和用法backface-visibility属性定义当前元素不面向屏幕时是否可见，如果元素在旋转后不希望看到背面，则可以使用。 visible：背面是可见的（默认值） hidden：背面是不可见的 实现的思路要实现类似的翻牌效果，首先我们需要有一张可以翻的牌，这张牌由两个元素重叠组成，位于上层正面我们看到，而位于下层的背面我们看不到并且本身是绕Y轴旋转过的，这样，当鼠标移动上去后，同时让正面和背面执行旋转就可以实现翻牌效果。 实现基本结构代码如下： 12345678910111213141516&lt;div id=\"content\"&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=\"#\" &gt; &lt;div&gt; &lt;h3&gt;测试正面1&lt;/h3&gt; &lt;p&gt;文字文字文字文字文字文字文字文字文字文字文字&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;测试背面1&lt;/h3&gt; &lt;p&gt;文字文字文字文字文字文字文字文字文字文字文字&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ul,li &#123; margin:0; padding:0; list-style:none;&#125;#content ul li&#123; width: 225px; height: 180px;&#125;#content ul li a&#123; position: relative; display: block; width: 100%; height: 100%;&#125;#content ul li a &gt; div&#123; position: absolute; left: 0; height: 0; width: 100%; height: 100%; color: #fff;&#125;#content ul li a div:first-child&#123; background-color: rgb(255, 64, 129); z-index:2;&#125;#content ul li a div:last-child&#123; background:rgb(0, 188, 212); z-index:1;&#125;#content ul li a div h3&#123; margin: 0 auto 15px; padding: 15px 0; width: 200px; height: 16px; line-height: 16px; font-size: 14px; text-align: center; border-bottom: 1px #fff dashed;&#125;#content ul li a div p&#123; padding: 0 10px; font-size: 12px; text-indent: 2em; line-height: 18px;&#125; 这样就让两个div叠在一起了，但是如果要进行翻转的话，首先是需要将背面本身就翻过去，当鼠标放上去之后翻转过来，让我们看到，所以我们需要给背面添加翻转180°的属性，鼠标放上去之后让它翻转到0°，同时为保证每个浏览器渲染统一，给正面加一个翻转0°，鼠标移动上去之后翻转-180°，并且是一个动画，所以要添加过渡。所以给正面背面添加CSS如下： 1234567891011121314151617181920#content ul li a &gt; div&#123; -webkit-transition:.8s ease-in-out; -moz-transition:.8s ease-in-out;&#125;#content ul li a div:first-child&#123; -webkit-transform:rotateY(0); -moz-transform:rotateY(0);&#125;#content ul li a div:last-child&#123; -webkit-transform:rotateY(180deg); -moz-transform:rotateY(180deg);&#125;#content ul li a:hover div:first-child&#123; -webkit-transform:rotateY(-180deg); -moz-transform:rotateY(-180deg);&#125;#content ul li a:hover div:last-child&#123; -webkit-transform:rotateY(0); -moz-transform:rotateY(0);&#125; 在添加这些CSS3属性后，可以实现翻转，但是发现只看到正面，没有看到背面，这又是为什么呢，前面提到有一个属性backface-visibility，这个属性用于控制在翻转后，元素的背面是否可见，默认是可见的，所以就会挡着背面那个元素，我们需要手动设置元素翻转后背面不可见，所以需要设置： 1234#content ul li a &gt; div&#123; -webkit-backface-visibility: hidden; -moz-backface-visibility: hidden;&#125; 这样设置之后，由于正面的元素在翻转后背面不可见，我们就可以看到背面的元素了。 但是，仔细观察会发现这个翻转似乎并不是那么立体，似乎在两条平行线之间实现了翻转，所以我们需要设置一个观察点距离视图的距离，这时候就需要给父元素添加perspective属性，这个属性的值一般为800px ~ 1000px，这个范围内的值会看上去合理。所以给父元素添加： 1234#content ul li a&#123; -webkit-perspective: 800px; -moz-perspective: 800px;&#125; 至此，就实现了一个翻转卡牌的效果，但是这里需要解决一个问题，因为perspective属性不被IE支持（Microsoft Edge支持），所以需要进行降级，我的做法是直接显示隐藏。那么如何识别IE9+浏览器呢？在stackoverflow中我找到了答案： 附：CSS中识别各类IE的方法IE6123* html .ie6&#123; property:value;&#125; or 123html .ie6&#123; _property:value;&#125; IE7123*+html .ie7&#123; property:value;&#125; or 123*:first-child+html ie7&#123; property:value;&#125; IE6 and IE7123@media screen\\9&#123; ie67&#123;property:value;&#125;&#125; or 1.ie67&#123; *property:value;&#125; or 1.ie67&#123; #property:value;&#125; IE6,7 and 8123@media \\0screen\\,screen\\9&#123; ie678&#123;property:value;&#125;&#125; IE81html&gt;/**/body .ie8&#123;property:value;&#125; or 123@media \\0screen&#123; ie8&#123;property:value;&#125;&#125; 只在IE8标准模式1.ie8&#123;property/*\\**/:value\\9;&#125; IE8,9 and 10123@media screen\\0&#123; ie8910&#123;property:value;&#125;&#125; IE9 only1234@media screen and (min-width:0\\0) and (min-resolution: .001dpcm)&#123; /*IE9 CSS*/ .ie9&#123;property:value;&#125;&#125; IE9+1234@media screen and (min-width:0\\0) and (min-resolution: +72dpi)&#123; /*IE9+ CSS*/ .ie9up&#123;property:value;&#125;&#125; IE9 and 10123@media screen and (min-width:0)&#123; .ie910&#123;property:value;&#125;&#125; IE10 only1_:-ms-lang(x), ie10 &#123;property:value;&#125; IE10+1_:-ms-lang(x), ie10up&#123;property:value;&#125; or 123@media all and (-ms-high-contrast:none),(-ms-high-contrast:active)&#123; .ie10up&#123;property:value;&#125;&#125; IE11+1_:-ms-fullscreen, :root .ie11up&#123;property:value;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/categories/CSS/"}]},{"title":"Javascript中字符串方法总结","slug":"js-String","date":"2016-08-14T08:48:34.000Z","updated":"2016-08-14T08:51:11.382Z","comments":true,"path":"2016/08/14/js-String/","link":"","permalink":"http://mrzhang123.github.io/2016/08/14/js-String/","excerpt":"字符方法chartAt()与charCodeAt()参数：基于0的字符位置 chartAt()以单字符字符串的形式返回给定位置的那个字符。而charCodeAt()返回的是字符编码。 123var stringValue = 'hello world';/*chartAt()*/console.log(stringValue.chartAt(1)); // 'e'","text":"字符方法chartAt()与charCodeAt()参数：基于0的字符位置 chartAt()以单字符字符串的形式返回给定位置的那个字符。而charCodeAt()返回的是字符编码。 123var stringValue = 'hello world';/*chartAt()*/console.log(stringValue.chartAt(1)); // 'e' 字符串操作方法concat()(数组中也有该方法)参数：一个或多个字符串 将一个会多个字符串拼接起来，当然更常用的是使用 “+” 进行拼接 substring()与slice()(数组中也有此方法)参数：指定子字符串的开始位置，子字符串到哪里结束 作用：创建新的子字符串（可以理解为字符串截取） substr()参数：指定子字符串的开始位置，返回的子字符串的字符个数 作用：创建新的子字符串（可以理解为字符串截取） repeat()（ES6新增）参数：数字（表示重复的次数） 作用：将原字符串重复n次 如果传入负数，则报错，传入小数和NaN等同于传入0 substring，slice，substr，repeat均返回子字符串，不会修改原来的字符串 1234567891011var stringValue = \"hello world\"; alert(stringValue.slice(3)); //\"lo world\" alert(stringValue.substring(3)); //\"lo world\" alert(stringValue.substr(3)); //\"lo world\" alert(stringValue.slice(3, 7)); //\"lo w\" alert(stringValue.substring(3,7)); //\"lo w\" alert(stringValue.substr(3, 7)); //\"lo worl\" /*repeat()*/var a = 'he';var b = a.repeat(3);console.log(`$&#123;a&#125;---$&#123;b&#125;`); / //\"he---hehehe\" 当给这三个方法传入负值的时候，三个的表现不同： slice()会将传入的负值与字符串的长度相加 substr()会将第一个位置的负值参数加上字符串长度后转为正数，而第二个位置的负值将转化为0 substring()会把所有的负参数转化为0 repeat()会报错 字符串位置方法indexOf()和lastIndexOf()(数组中也有该方法)参数：要搜索的子字符串，开始搜索的位置（可选） 搜索给定的子字符串，如果找到则返回位置，否则返回-1 123var stringValue = \"hello world\"; alert(stringValue.indexOf(\"o\")); //4 alert(stringValue.lastIndexOf(\"o\")); //7 这两个方法在搜索到第一个匹配的子字符串后就停止运行，所以如果想找到字符串中所有的子字符串出现的位置，可以循环调用indexOf或lastIndexOf。 12345678910var stringValue = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit\"; var positions = new Array(); var pos = stringValue.indexOf(\"e\"); while(pos &gt; -1)&#123; positions.push(pos); pos = stringValue.indexOf(\"e\", pos + 1); &#125; alert(positions); //\"3,24,32,35,52\" ES6新增includes()、startsWith()、endsWith() includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部 这三个方法的参数与indexOf()，lastIndexOf()一样 1234var s = 'Hello world';s.startsWith('world',6); // trues.endsWith('Hello',5); // trues.includes('Hello',6); //false 注意：使用第2个参数n时，endsWith的行为与其他两个方法有所不同。它针对前面n个字符，而其他两个方法针对从第n个位置开始直到字符串结束的字符。 去空格–trim()ES5中新增trim()方法用于去除字符串的左右空格，该方法会创建一个字符串的副本，不会改变原有的字符串，此外，Firefox 3.5+、Safari 5+和 Chrome 8+还支持非标准的 trimLeft()和 trimRight()方法，分别用于删除字符串开头和末尾的空格。 其实去空格可以使用正则去匹配的去掉，这里写一个去空格函数 123456789101112131415/*trim 去掉空白str要处理的字符串 [type] 类型：l 去除左边的空白 r去除右边空白 b去掉两边的空白 a去除所有空白*/function trim (str,type) &#123; var type=type||\"b\"; if(type==\"b\")&#123; return str.replace(/^\\s*|\\s*$/g,\"\"); &#125;else if(type==\"l\")&#123; return str.replace(/^\\s*/g,\"\"); &#125;else if(type==\"r\")&#123; return str.replace(/\\s*$/g,\"\"); &#125;else if(type==\"a\")&#123; return str.replace(/\\s*/g,\"\"); &#125;&#125; 字符串大小写转换toLowerCase()、toLocaleLowerCase()、toUpperCase()和 toLocaleUpperCase()字符串的模式匹配方法match()参数：一个正则表达式或RegExp对象 返回一个数组。在字符串上调用这个方法本质上与调用RegExp的exec()方法相同。 12345678var text = \"cat, bat, sat, fat\"; var pattern = /.at/; //与 pattern.exec(text)相同 var matches = text.match(pattern); alert(matches.index); //0 alert(matches[0]); //\"cat\" alert(pattern.lastIndex); //0 search()参数：一个正则表达式或RegExp对象 返回字符串中第一个匹配项的索引，如果没有找到，则返回-1 123var text = \"cat, bat, sat, fat\"; var pos = text.search(/at/); alert(pos); //1 replace()参数：一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），一个字符串或一个函数 利用replace()进行替换的时候，如果传入的是字符串，则只会替换第一个子字符串，要想替换所有的子字符串，则需要传入一个正则表达式，而且要指定全局（g）标志 123456var text = 'cat , bat , sat , fat';var result = text.replace('at','ond');console.log(result); // =&gt;'cont , bat , sat , fat'result = text.replace(/at/g,'ond');console.log(result); //=&gt;'cont , bont , sont , font' 该方法并不改变调用它的字符串本身，只是返回一个新的替换后的字符串。 当第二个参数为函数时函数的返回值作为替换字符串。与第二个参数是字符串一样，如果第一个参数是正则表达式，并且全局匹配，则这个函数的方法将被多次调用，每次匹配都会被调用。 该函数的参数： match：匹配的子串 p1,p2…：假如replace()方法的第一个参数是RegExp对象，则代表第n个括号匹配的字符串。 offset：匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串时“bc”，那么这个参数是1） 被匹配的原字符串 123456789101112131415161718function replacer(match , p1 , p2 , p3 , offset , string)&#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics console.log(`$&#123;match&#125; $&#123;p1&#125; $&#123;p2&#125; $&#123;p3&#125; $&#123;offset&#125; $&#123;string&#125;`); /* =&gt; abc12345#$*% abc 12345 #$*% 0 abc12345#$*%\" */ console.log([p1, p2, p3].join(' - ')); // =&gt; \"abc - 12345 - #$*%\" return [p1, p2, p3].join(' - ');&#125;var newString = 'abc12345#$*%'.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer); // =&gt;\"abc - 12345 - #$*%\" split()参数：用于分隔字符串的分隔符，数字（可选，用于指定数组的大小） 作用：基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中，分隔符可以是字符串，也可以是RegExp对象 1234var color = 'red,blue,yellow,black';var color1 = color.split(','); // =&gt;['red','blue','yellow','black']var color2 = color.split(',',2); // =&gt;['red','blue']var color3 = color.split(/[^\\,]+/); // =&gt;[\"\", \",\", \",\", \",\", \"\"] 最后一个调用split的时候，出现了前后的两个空白，是因为通过正则表达式指定的分隔符出现在了字符串的开头和结尾。 localeCompare()这个方法用于比较两个字符串，并返回下列值中的一个： 如果字符串在字母表中应该排在字符串参数之前，则返回负数（大多情况下为-1） 如果相等，则返回0 如果排在字符串参数之前，则返回正数（大多数情况下为1） fromCharCode()String构造函数的一个静态方法 参数：一个或多个字符串编码 作用：将接收到的一个或多个字符串编码转换成一个字符串，这个方法与实例方法charCodeAt()执行相反的操作。 1234567891011121314/*fromCharCode*/String.fromCharCode(104,101,108,108,111); // =&gt;hello/*charCodeAt*/let s = 'hello';for(let i=0;i&lt;s.length;i++)&#123; console.log(`$&#123;s[i]&#125;----$&#123;s[i].charCodeAt()&#125;`);&#125;/*\"h----104\"\"e----101\"\"l----108\"\"l----108\"\"o----111\"*/ 最后写一个字符串与数组方法应用的一个例子，熟悉它们方法的话很简单，不熟悉就会觉得有点儿乱。 123let s = 'hello';let news = s.split('').reverse().join('');console.log(news); // =&gt; \"olleh\" 另附js中String和Array方法的总结图：","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/tags/Javascript/"}],"keywords":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}]},{"title":"JS中的位置与大小","slug":"js-position","date":"2016-08-02T16:06:31.000Z","updated":"2016-08-02T16:35:40.889Z","comments":true,"path":"2016/08/03/js-position/","link":"","permalink":"http://mrzhang123.github.io/2016/08/03/js-position/","excerpt":"最近事儿比较多，一直没时间写东西，前几天又遇到关于获取元素大小的问题，每次遇到这类问题就翻书，比较费时间，所以总结一下。 1.元素的偏移量元素的偏移量包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意：这里并不包括外边距）。","text":"最近事儿比较多，一直没时间写东西，前几天又遇到关于获取元素大小的问题，每次遇到这类问题就翻书，比较费时间，所以总结一下。 1.元素的偏移量元素的偏移量包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意：这里并不包括外边距）。 2.客户区大小元素的客户区大小指的是元素内容机器内边距占据空间的大小。 要确定浏览器可见窗口的大小，可以使用document.documentElement或document.body（IE7之前的版本中）。 从以上两个我们可以看出元素偏移量（offset）与客户区大小（client）的区别在于有没有包含边框，客户区大小不包含边框。 3.滚动大小 scrollWidth和scrollHeight主要用于确定元素内容的实际大小。所以带有垂直滚动条的页面总高度就是document.documentElement.scrollHeight。 4.窗口大小在现代主流浏览器中提供了四个属性确定窗口的大小，分别为：innerWidth、innerHeight、outerWidth和outerHeight。 4.1. outerWidth和outerHeight返回浏览器窗口本身的尺寸（无论是从外层的window对象还是从某个框架访问） 4.2. innerWidth和innerHeight返回该容器中页面试图去的大小（减去边框宽度） 注意： 这里在《javascript高级程序设计》（第三版）中写道在chrome中outer与inner返回的值是一样的，这算是chrome的一个bug，我在chrome 53中已经修复，但是在QQ浏览器中（内核为chromium47）依旧是相等的，这需要注意！clientWidth和clientHeight。 在主流浏览器中，document.docuementElement.clientWidth和document.documentElement.clientHeight中保存的是页面视口信息。返回的值与window.innerHeight，window.innerWidth一样。但是window.innerHeight在IE8及以下浏览器中结果是undefined，而document.documentElement.clientHeight还有值。所以在各个浏览器下取得页面视口大小的代码如下：1234567891011var pageWidth=window.innerWidth, pageHeight=window.innerHeight;if(typeof pageWidth !== 'number')&#123; if(document.compatMode === 'CSS1Compat')&#123; pageWidth=document.documentElement.clientWidth; pageHeight=document.documentElement.clientHeight; &#125;else&#123; pageWidth=document.body.clientWidth; pageHeight=document.body.clientHeight; &#125;&#125; 代码中document.compatMode用于判断浏览器处于什么模式，它有两个值：BackCompat:浏览器处于怪异模式CSS1Compat:浏览器处于标准模式不同模式下，获取浏览器的宽度的方法不同，在代码中已经做了判断。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/tags/Javascript/"}],"keywords":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}]},{"title":"Javascript中Array方法的总结","slug":"js-Array","date":"2016-08-02T16:01:05.000Z","updated":"2016-08-02T16:35:52.349Z","comments":true,"path":"2016/08/03/js-Array/","link":"","permalink":"http://mrzhang123.github.io/2016/08/03/js-Array/","excerpt":"在ECMAScript中最常用的类型之一就是Array类型，Array类型的方法也有很多，所以在这篇文章中，梳理一下Array类型的方法。 新建数组新建数组的方法有三种： 123456/*方法一*/var a = new Array(1,2,3);/*方法二*/var b = [1,2,3];/*方法三（ES6新增）*/var c = Array.of(1,2,3); Array.of()是ES6中新增的将一组值转换为数组的方法，该方法的出现时为了弥补构造函数Array()因为参数不同导致的不同行为。 123Array() //[]Array(3) //[ , , ]Array(1,2,3) //[1,2,3] 从上面可以看出，只有在参数个数不少于2时候，才会返回新的数组。","text":"在ECMAScript中最常用的类型之一就是Array类型，Array类型的方法也有很多，所以在这篇文章中，梳理一下Array类型的方法。 新建数组新建数组的方法有三种： 123456/*方法一*/var a = new Array(1,2,3);/*方法二*/var b = [1,2,3];/*方法三（ES6新增）*/var c = Array.of(1,2,3); Array.of()是ES6中新增的将一组值转换为数组的方法，该方法的出现时为了弥补构造函数Array()因为参数不同导致的不同行为。 123Array() //[]Array(3) //[ , , ]Array(1,2,3) //[1,2,3] 从上面可以看出，只有在参数个数不少于2时候，才会返回新的数组。 数组的检测对于一个网页或者一个全局作用域而言，使用instanceof操作符检测，通过返回的boolean值可以得出是否为数组，但是这样检测的问题在如果网页中包含两个以上不同的全局作用域，就会从在两个以上不同版本的Array构造函数，如果从一个框架向另一个框架传入一个数组，那么传入的数组与第二个框架中原声创建的数组分别有不同的构造函数。在ES5中引入的Array.isArray()解决了这个问题，但如果在不支持ES5的浏览器中检测数组，则需要些兼容性方法，所以检测数组的方法如下：1234567function checkArray(arr) &#123; if(typeof Array.isArray)&#123; return Array.isArray(arr); &#125;else&#123; return Object.prototype.toString.call(arr)==='[object Array]'; &#125;&#125; 数组中的方法：更改原数组添加项push():接收任意数量的参数，逐个将其添加至数组末尾，返回修改后的数组的长度unshift():在数组的前端添加任意个项并返回新数组的长度 移除项pop():从数组末尾移除最后一项，返回移除的项shift():移除数组中的第一项并返回该项 排序reverse():反转数组项的顺序 123var values = [1,2,3,4,5];values.reverse();console.log(values); // =&gt;5,4,3,2,1 sort():按照升序排列数组项，但是它在实现排序时会调用每个数组项的toString()放法，去比较字符串，所以会出现如下情况 123var values = [0,1,5,10,15];values.sort();console.log(values); // =&gt; 0,1,10,15,5 为了在使用sort()方法时返回正确的排序，我们需要给sort()传入一个比较函数，该比较函数传入两个参数，如果第一个参数应该位于第二个参数之前则返回一个负数，如果两个参数相等返回0，如果第一个参数应该位于第二个参数之后则返回一个正数。 1234567891011121314/*升序降序则更改返回值即可*/function compare(value1,value2)&#123; if(value1 &lt; value2)&#123; return -1; &#125;else if(value1 &gt; value2)&#123; return 1; &#125;else &#123; return 0; &#125;&#125;var values = [0,1,5,10,15];values.sort(compare);console.log(values); 对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个简单的比较函数 123function compare(value1,value2)&#123; return value2 - value1;&#125; 截取slice():接受一个或两个参数，要返回的起始位置到结束位置但不包括结束位置项，如果只写一个参数则截取数组到最后。可以接收负数作为参数splice():做多可以接收三个参数，分别为起始位置，要删除的项目数，要插入的任意数量的项，同个这三个参数是否传入可以实现删除，插入，替换 123456789101112var colors =['red','green','blue'];var removed =colors.splice(0,1); //删除第一项console.log(colors); //green,blueconsole.log(removed); //redm,返回的数组中只包含一项removed = colors.splice(1,0,'yellow','orange'); //从位置1开始插入两项console.log(colors); //green,yellow,orange,blueconsole.log(removed); //返回的是一个空数组removed = color.splice(1,1,'red','purple'); //插入两项，删除一项console.log(colors); //green,yellow,purple,orange,blueconsole.log(removed); //返回yellow copyWithin()参数： target(必需)：从该位置开始替换数据 start (可选)：从该位置开始读取数据，默认为0。如果为负值，表示倒数 end (可选)：到该位置前停止读取数据，默认等于数组长度。如果为负值表示倒数 在当前数组内部将指定位置的成员复制到其他位置，会覆盖原来的成员。修改原来的数组形成新的数组 1234var a = [1,2,3];var b = a.copyWithin(0); // =&gt;[1,2,3]var c = a.copyWithin(0,1); // =&gt;[2,3,3]var d = a.copyWithin(0,1,2);// =&gt;[2,2,3] 上面例子可以看出，虽然copyWithin的后两个参数是可选的，但是需要写第二个参数，否则返回的只是原数组本身。 不更改原素组，生成新数组操作方法concat():这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾并返回副本。 1234var a = [1,2,3];var b = a.concat('a','b',['c','d','e']);console.log(a); // =&gt;1,2,3console.log(b); 寻找1.indexOf()、lastIndexOf()与includes()indexOf()与lastIndexOf()用于查找数组中是否有该方法，如果有则返回该元素的位置，否则返回-1。但是这个方法有两个缺点： 不够语义化 它内部使用严格等于运算符===，导致了对NaN的误判。所以ES7新增includes()去克服这些缺点。 ES7新增ES7中新增includes()方法，用于查找数组总是否包含某个元素，返回布尔值，接受两个参数要查找的元素和查找的起始位置。 2.find()和findIndex()参数：一个回掉函数回调的参数：当前值、当前位置、原数组 find()方法用于找出第一个符合条件的数组成员。findIndex()方法返回第一个符合条件的数组成员的位置，如果所有成员都不符合，则返回-1。 1234567var a = [1,4,-5,10];a.find((n)=&gt; n&lt;0); // -5var b = [1,5,10,15];b.findIndex(function(value,index,arr)&#123; return value &gt; 9;&#125;);//=&gt;2 迭代方法ES5为数组定义了五个迭代方法每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象—-影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。 every():对数组中的每一项运行给定的函数，如果该函数对每一项都返回true,则返回true some():对数组中每一项运行给定的函数，如果该函数对任一项返回true，则返回true filter():对数组中每一项运行给定的函数，返回该函数会返回true的项组成的数组 forEach():对数组中的每一项运行给定的函数。没有返回值 map():对数组中的每一项运行给定的函数，返回每次调用的结果组成的数组 归并方法reduce()该方法可以传递两个参数：化简函数，传递给函数的初始值（可选）。化简函数的参数：到目前为止的化简操作累积的结果，数组元素，元素的索引，数组本身。这个方法，可以用于求数组元素的和、积、最大值。 1234567var a = [1,2,3,4,5]/*求和*/var sum = a.reduce((x,y)=&gt;x+y,0);/*求积*/var product = a.reduce((x,y)=&gt;x*y,1);/*求最大值*/var max = a.reduce((x,y)=&gt;(x&gt;y)?x:y); 这个方法的简单用法就是这样，在《javascript高级程序设计》（第三版）中只是介绍了这个用法，但是在《javascript权威指南》（第六版）中提到了reduce的高级用法。例1：求任意数目对象的“并集” 123456789/*返回一个新对象，这个对象同时拥有o和p的属性如果o和p中有重名属性，使用p中属性*/function union(o,p)&#123; return extend(extend(&#123;&#125;,o),p);&#125;var objects = [&#123;x:1&#125;,&#123;y:2&#125;,&#123;z:3&#125;];var merged = objects.reduce(union); // =&gt;&#123;x:1,y:2,z:3&#125; 例2：统计字符串中每个字符出现的重复次数 123var arr = 'abcdabcdadbc';var info = arr.split('').reduce((p,k) =&gt; (p[k]++ || (p[k] = 1), p), &#123;&#125;);console.log(info); //=&gt; Object &#123;a: 3, b: 3, c: 3, d: 3&#125; 这两个例子，尤其是第二个例子可以看出，reduce()并不单单只是用于数学计算，在第二个例子中可以明显看出在reduce()第二个参数传入一个空对象，此时它最终返回的就是一个对象。由于本身传入的初始值是对象，所以返回对象。如果传入一个空数组，则返回数组。所以可以看出，最终reduce()函数返回什么，取决于第二个参数的形式。 join()Array.join()方法将数组中的所有元素都转化为字符串并连接起来，返回最后生成的字符串。可以指定一个可选的字符串在生成的字符串中分隔数组的各个元素，如不指定，默认用逗号隔开。 fill()参数：填充项、填充的起始位置、填充的结束位置fill()方法用于使用给定的值填充数组。 1new Array(3).fill(7); //=&gt;[7,7,7] 转换为数组的方法(ES6新增)Array.from();该方法接收两个参数要转换的非数组对象,对每个元素进行处理的方法（可选） 在js中，有很多类数组对象（array-like object）和可遍历（iterable）对象（包括ES6新增的数据结构Set和Map），常见的类数组对象包括document.querySelectorAll()取到的NodeList，以及函数内部的arguments对象。它们都可以通过Array.from()转换为真正的数组，从而使用数组的方法。事实上只要对象具有length属性，就可以通过Array.from()转换为真正的数组。 1234567var a = &#123; 0:'li', 1:'li', 2:'li', length:3&#125;;console.log(Array.from(a)); // =&gt; ['li','li','li']; 1Array.from([1,2,3],(x)=&gt;x*x); // =&gt;1,4,9 扩展运算符（…）123456//arguments对象function foo()&#123; var args = [...arguments];&#125;//nodelist[...document.querySelectorAll('div')];","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/tags/Javascript/"}],"keywords":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}]},{"title":"Vuejs的一些总结","slug":"summarize-vue","date":"2016-07-13T16:07:45.000Z","updated":"2016-07-14T04:00:50.814Z","comments":true,"path":"2016/07/14/summarize-vue/","link":"","permalink":"http://mrzhang123.github.io/2016/07/14/summarize-vue/","excerpt":"最近一段时间忙着工作的一些事情，同时自己也在试着把项目中的一些移动端页面试着用vuejs重写，所以没时间写文章，今天终于有空可以写一下，由于页面并没有写完，所以就将自己这几天做页面的时候遇到的一些问题总结了一下。其实很多在官网都能找到，但是我们只看官网教程不去写，很难理解到底是什么意思，这里我把我用到的列出来。 文章中提到的很多东西都在我的demo中用到，demo地址","text":"最近一段时间忙着工作的一些事情，同时自己也在试着把项目中的一些移动端页面试着用vuejs重写，所以没时间写文章，今天终于有空可以写一下，由于页面并没有写完，所以就将自己这几天做页面的时候遇到的一些问题总结了一下。其实很多在官网都能找到，但是我们只看官网教程不去写，很难理解到底是什么意思，这里我把我用到的列出来。 文章中提到的很多东西都在我的demo中用到，demo地址 1.Vuejs组件vuejs构建组件使用1Vue.component('componentName',&#123; /*component*/ &#125;)； 这里注意一点，组件要先注册再使用，也就是说：1234567891011121314Vue.component('mine',&#123; template:'#mineTpl', props:['name','title','city','content'] &#125;); var v=new Vue(&#123; el:'#vueInstance', data:&#123; name:'zhang', title:'this is title', city:'Beijing', content:'these are some desc about Blog' &#125;&#125;); 如果反过来会报错，因为反过来代表先使用了组件的，但是组件却没注册。 webpack报错后，使用webpack --display-error-details可以排错 2.指令keep-alive在看demo的时候看到在vue-router写着keep-alive，keep-alive的含义：如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令1&lt;component :is='curremtView' keep-alive&gt;&lt;/component&gt; 3.如何让css只在当前组件中起作用在每一个vue组件中都可以定义各自的css，js，如果希望组件内写的css只对当前组件起作用，只需要在style中写入scoped，即：1&lt;style scoped&gt;&lt;/style&gt; 4.vuejs循环插入图片在写循环的时候，写入如下代码：123&lt;div class=\"bio-slide\" v-for=\"item in items\"&gt; &lt;img src=\"&#123;&#123;item.image&#125;&#125;\"&gt;&lt;/div&gt; 此时在控制台会出现警告[Vue Warn]: src=&quot;&quot;: interpolation in &quot;src&quot; attribute will cause a 404 request. Use v-bind:src instead.这里意思是在“src”属性插值将导致404请求。使用v-bind：src代替。所以替换成如下：123&lt;div class=\"bio-slide\" v-for=\"item in items\"&gt; &lt;img v-bind:src=\"item.image\"&gt;&lt;/div&gt; 这里需要主要，v-bind在写的时候不能再用双花括号，根据官方的说法：1&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt; 这里href是参数，它告诉 v-bind指令将元素的 href特性跟表达式 url 的值绑定。可能你已注意到可以用特性插值href=&quot;&quot; 获得同样的结果：这样没错，并且实际上在内部特性插值会转为v-bind 绑定。 5.绑定value到Vue实例的一个动态属性上对于单选按钮，勾选框及选择框选项，v-model绑定的value通常是静态字符串（对于勾选框是逻辑值）：12&lt;!-- `toggle` 为 true 或 false --&gt;&lt;input type=\"checkbox\" v-model=\"toggle\"&gt; 但是有时候想绑定value到vue实例的一个动态属性上，这时可以用v-bind实现，并且这个属性的值可以不是字符串。例如绑定Checkbox的value到vue实例的一个动态属性：123456&lt;input type=\"checkbox\" v-model=\"toggle\" v-bind:true-value=\"a\" v-bind:false-value=\"b\"&gt;&lt;p&gt;&#123;&#123;toggle&#125;&#125;&lt;/p&gt; 这里绑定后，并不是说就可以点击后由true,false的切换变为a,b的切换，因为这里定义的动态a，b是scope上的a,b，并不能直接显示出来，此时1234//当选中时vm.toggle === vm.a//当没选中时vm.toggle === vm.b 所以此时需要在data中定义a,b，即：1234567new Vue(&#123; el:'...', data:&#123; a:'a', b:'b' &#125;&#125;); 6.片段实例下面几种情况会让实例变成一个片断实例： 模板包含多个顶级元素。 模板只包含普通文本。 模板只包含其它组件（其它组件可能是一个片段实例）。 模板只包含一个元素指令，如&lt;partial&gt; 或vue-router 的 &lt;router-view&gt;。 模板根节点有一个流程控制指令，如v-if或v-for。 这些情况让实例有未知数量的顶级元素，它将把它的 DOM 内容当作片断。片断实例仍然会正确地渲染内容。不过，它没有一个根节点，它的$el 指向一个锚节点，即一个空的文本节点（在开发模式下是一个注释节点）。但是更重要的是，组件元素上的非流程控制指令，非 prop 特性和过渡将被忽略，因为没有根元素供绑定：12345678&lt;!-- 不可以，因为没有根元素 --&gt;&lt;example v-show=\"ok\" transition=\"fade\"&gt;&lt;/example&gt; &lt;!-- props 可以 --&gt;&lt;example :prop=\"someData\"&gt;&lt;/example&gt; &lt;!-- 流程控制可以，但是不能有过渡 --&gt;&lt;example v-if=\"ok\"&gt;&lt;/example&gt; 片段实例也有用处，但是通常情况下组件有一个根节点比较好，它会保证组件元素上的指令和特性能正确的转换，同时性能也稍微好些。 7.路由嵌套路由嵌套会将其他组件渲染到该组件内，而不是进行整个页面跳转router-view本身就是将组件渲染到该位置，想要进行页面跳转，就要将页面渲染到根组件，在起始配置路由时候写到：12var App = Vue.extend(&#123; root &#125;);router.start(App,'#app'); 这里首先将根组件注册进来，用于将路由中配置好的各个页面渲染出来，然后将根组件挂载到与#app匹配的元素上。 8.实现多个根据不同条件显示不同文字的方法v-if,v-else可以实现条件选择，但是如果是多个连续的条件选择，则需要用到计算属性computed。例如实现当输入框中什么都没写的时候显示字符串‘empty’,否则显示输入框中的内容，代码如下：1234&lt;div id=\"test\"&gt; &lt;input type=\"text\" v-model=\"inputValue\"&gt; &lt;h1&gt;&#123;&#123;changeVaule&#125;&#125;&lt;/h1&gt;&lt;/div&gt; 123456789101112131415new Vue(&#123; el:'#test', data:&#123; changeVaule:'123' &#125;, computed :&#123; changeVaule:function()&#123; if(this.inputValue!=='')&#123; return this.inputValue; &#125;else&#123; return 'empty'; &#125; &#125; &#125;&#125;); 9.Vuejs在变化检测问题1.检测数组由于javascript的限制，vuejs不能检测到下面数组的变化： 直接索引设置元素，如vm.item[0]={}; 修改数据的长度，如vm.item.length。 为了解决问题1，Vuejs扩展了观察数组，为它添加一个$set()方法：12// 与 `example1.items[0] = ...` 相同，但是能触发视图更新example1.items.$set(0, &#123; childMsg: 'Changed!'&#125;) 问题2，需要一个空数组替换items。 除了$set()，vuejs也为观察数组添加了$remove()方法，用于从目标数组中查找并删除元素，在内部调用了splice()。因此，不必：1234var index = this.items.indexOf(item)if (index !== -1) &#123; this.items.splice(index, 1)&#125; 只需：1this.items.$remove(item); 2.检测对象受ES5的显示，Vuejs不能检测到对象属性的添加或删除。因为Vuejs在初始化时候将属性转化为getter/setter，所以属性必须在data对象才能让Vuejs转换它，才能让它是响应的，例如：1234567891011var data = &#123; a: 1 &#125;var vm = new Vue(&#123; data: data&#125;)// `vm.a` 和 `data.a` 现在是响应的 vm.b = 2// `vm.b` 不是响应的 data.b = 2// `data.b` 不是响应的 不过，有办法在实例创建之后添加属性并且让它是响应的。对于Vue实例，可以使用$set(key,value)实例方法：12vm.$set('b', 2)// `vm.b` 和 `data.b` 现在是响应的 对于普通数据对象，可以使用全局方法Vue.set(object, key, value):12Vue.set(data, 'c', 3)// `vm.c` 和 `data.c` 现在是响应的 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 添加属性。但是，添加到对象上的新属性不会触发更新。这时可以创建一个新的对象，包含原对象的属性和新的属性：12// 不使用 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 10.关于vuejs页面闪烁在vuejs指令中有v-cloak，这个指令保持在元素上直到关联实例结束编译。和CSS规则如[v-cloak]{display:none}一起用时，这个指令可以隐藏未编译的Mustache标签直到实例准备完毕。用法如下：123[v-cloak]&#123; display:none;&#125; 1&lt;div v-cloak&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; 这样&lt;div&gt;不会显示，直到编译结束 11.关于在v-for循环时候v-model的使用有时候需要循环生成input，用v-model绑定后，利用vuejs操作它，此时我们可以在v-model中写一个数组selected[$index]，这样就可以给不同的input绑定不同的v-model，从而分别操作他们。这个我在demo中的dataBind.vue中用到。 12.vuejs中过渡动画在vuejs中，css定义动画：123456789101112131415161718.zoom-transition&#123; width:60%; height:auto; position: absolute; left:50%; top:50%; transform: translate(-50%,-50%); -webkit-transition: all .3s ease; transition: all .3s ease; &#125; .zoom-enter, .zoom-leave&#123; width:150px; height:auto; position: absolute; left:20px; top:20px; transform: translate(0,0); &#125; 其中动画在定的时候要注意上下对应，上面有什么，下面有什么，都要变化的，如果有不变化的，应该抽离出去，作为公共css样式，在上面的css中，如果我只写transform: translate(-50%,-50%);而不写下面的transform: translate(0,0);则会导致上面的transform: translate(-50%,-50%);被添加到下面，认为这个是不变的。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mrzhang123.github.io/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://mrzhang123.github.io/tags/vue/"}],"keywords":[{"name":"Vue","slug":"Vue","permalink":"http://mrzhang123.github.io/categories/Vue/"}]},{"title":"六月总结","slug":"summarize-June","date":"2016-06-29T16:03:50.000Z","updated":"2016-07-14T03:18:23.463Z","comments":true,"path":"2016/06/30/summarize-June/","link":"","permalink":"http://mrzhang123.github.io/2016/06/30/summarize-June/","excerpt":"不知不觉中，六月已经过去，七月悄悄到来，写这篇文章，总结六月，并给七月做一些计划。在未来，每个月都会做一次总结，无论得失，都记录下来，记录自己的成长。 &emsp;&emsp;六月结束，2016年也已过去一半。六月收获很多，无论是工作还是生活。在2015年年底的时候我曾经计划，在2016年要学习新的编程上的技术，每天跑步，学吉他，多读书。在六月，我终于全部开始做了。","text":"不知不觉中，六月已经过去，七月悄悄到来，写这篇文章，总结六月，并给七月做一些计划。在未来，每个月都会做一次总结，无论得失，都记录下来，记录自己的成长。 &emsp;&emsp;六月结束，2016年也已过去一半。六月收获很多，无论是工作还是生活。在2015年年底的时候我曾经计划，在2016年要学习新的编程上的技术，每天跑步，学吉他，多读书。在六月，我终于全部开始做了。 技能&emsp;&emsp;六月上旬的时候，因为公司没什么事儿，我又开始研究vuejs，其实关于vuejs，我很早的时候就知道了，记得去年的时候我关注勾三股四大神的微博，第一次知道vue，后来有看过vuejs的官方文档，但是由于自己在之前没有接触过MVVM框架，所以看起来非常吃力，根本看不懂官方的教程在说什么。前前后后看过也有那么两三次了，期间我也有意无意的关注过关于MVVM的一些概念什么的，并在掘金和segmentfault上面关注关于vue的文章，现在vue很火，所以文章也比较好找很多了，另外这两个网站不错，推荐给大家。&emsp;&emsp;这个月开始研究vue的时候，在segmentfault上面看到两篇关于vue的非常基础的文章，分别是从零开始学Vue和组件改变生活_揭开Vue组件的神秘面纱。正是这两篇文章让我开始真正的走进vue，而vue + webpack 起手式，让我开始了解webpack与vue是怎么配合从而实现利用vue写组件。正是这三篇文章，开始让我对vue和webpack有了了解并开始写一些demo，我把demo上传到了github，我的demo地址。&emsp;&emsp;其实我公司的业务没有用到vue，那为什么我去学呢，其实我觉得我自己学一些东西，就是好奇，现在的前端，模块儿化，MVVM，双向数据绑定等等一些东西的出现，让我感觉很好奇，我想知道为什么这些东西很受欢迎，为什么会火，所以才去慢慢的了解它，选择一个代表去学习它，当然了，如果将来有机会，我会把vue用到公司的项目中，给公司的前端技术带来新的东西（说实话现在我们公司依然用传统的前端开发模式让我觉得有点儿low了，哈哈）。正是这种好奇心驱使着我不断去探索一些对我来说的新东西，而前端变化太快，总有一些新东西可以让我去探索，这也是我选择前端，喜欢前端的重要原因。貌似扯的有点儿远了，哈哈。对了，就在上午，CTO让我下周分享vuejs的一些用法和心得，我很荣幸可以去给公司分享这些东西，只是我得认真准备一下啦，这个比较麻烦一点儿，嘿嘿。&emsp;&emsp;六月中旬的时候，我决定买把吉他玩，因为那时候我迷上了民谣，听赵雷的歌，像南方姑娘，未给姐姐寄出的信等等，决定买一个，其实我以前也听一些纯音乐，像钢琴，小提琴，吉他等等，但是为什么我选择吉他呢，因为吉他便宜，哈哈哈。我自己是程序员，我认为码代码是我的工作，但不能是我生活的全部，我不能一天到晚码代码，所以我搞了把吉他玩儿，在此之前从未对音乐这么认真过，小时候上过音乐课，但是和没上过一样，原因大家应该都懂的，哈哈。说实话，学吉他可不简单，自己本身有点儿胖，指头上的肉也不少，刚开始按的时候真的是，非常疼啊，不过我既然决定要学了，就要学会它，这半个月来，几乎每天都会抽出点儿时间来去练习，我的第一个目标就是能弹唱《南方姑娘》，为了这个目标，我得努力了。 成长&emsp;&emsp;六月开始我每天看会儿书，这个书不是编程的书，而是一些其他的书。其实我本身并不爱看书，小时候觉得看不看无所谓，我想看就看看，不想看就不看，没什么，但是越长大越觉得确实应该多读书，读书可以让我看到不一样的世界，不是有人说过么“现代人的问题在于读书太少而想的太多”，我想这也是烦恼的最大的来源，有时候我也很烦，所以我要努力做一个读书多的人。读的书越多，接触到的就越多，懂的也就越多。努力多读书，学会做人做事，这是我的目标。&emsp;&emsp;六月月底的时候，因为粗心在合并代码的时候把别人的给覆盖了，这让我们测试很生气，虽然并没有骂，但是看的出来，很生气，我也知道确实是自己的问题，所以不知道该说什么，只能默默的把原来的代码拷贝出来，然后把自己的功能加进去。事后在回家的路上我给我们测试发了QQ信息，给他道歉，我们测试也接受了我的道歉。六月底的时候我开始读卡耐基的《人性的弱点》，虽热在写本文的时候还没读完，但是我从前面的几个章节看得出来，它其实想告诉人们，做人最重要的是真诚，真心，错了就是错了，不需要辩解，给别人造成麻烦了，就要道歉，这是我悟到的一个道理，也算是一次成长吧。 新计划&emsp;&emsp;七月开始了，计划在这个月依旧学习vue，并改造公司移动端的项目，同时继续学习ES6，之前虽然学过，但是并没学完，七月继续。同时要每天跑步，说是跑步，不如说是对自己的一种在意志上的一种锻炼，一种坚持做一件事的态度。吉他练得虽然手疼吧，但是既然想学，就学好。从六月开始每个月都总结一下，记录自己一步步的成长，记录得与失，活出精彩，做最好的自己。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrzhang123.github.io/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://mrzhang123.github.io/tags/生活/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://mrzhang123.github.io/categories/生活/"}]},{"title":"基于Vue的简单的单页面应用","slug":"vue-demo-1","date":"2016-06-07T17:14:39.000Z","updated":"2016-07-14T04:07:23.938Z","comments":true,"path":"2016/06/08/vue-demo-1/","link":"","permalink":"http://mrzhang123.github.io/2016/06/08/vue-demo-1/","excerpt":"基于Vue的简单的单页面应用在对Vue和webpack有了一定了解后，我们就可以开始利用所了解的东西做一个简单的webapp了，不了解的同学可以看下我的前两篇关于vue和webpack的基本应用：webpack+vue起步利用webpack和vue实现组件化","text":"基于Vue的简单的单页面应用在对Vue和webpack有了一定了解后，我们就可以开始利用所了解的东西做一个简单的webapp了，不了解的同学可以看下我的前两篇关于vue和webpack的基本应用：webpack+vue起步利用webpack和vue实现组件化 构建项目首先创建各个组件，我的目录结构如下：123456789101112131415//没有后缀名的都是文件夹|-wechat |-dist |-src | |-components //存放vue组件 | | |-tab //存放home.vue中的tab，动态切换的模板 | | | |-tab_1.vue | | | |-tab_2.vue | | |-home.vue //app的首页 | | |-list.vue //点击home中的链接跳转到 | | |-detail.vue //点击list中的链接跳转到 | |-app.vue //主要的vue文件(用于将各个组件的挂载) | |-main.js //主要的js(用于配置路由) |-static //存放静态资源 |-index.html 配置路由首先在我们的项目中安装vue-router1npm install vue-router 引入各个组件并配置路由：1234567891011121314151617181920212223242526272829303132333435//main.jsimport Vue from 'vue';import VueRouter from 'vue-router';//引入组件import App from './app.vue';import home from './components/home.vue';import list from './components/list.vue';import detail from './components/detail.vue';Vue.use(VueRouter);var app=Vue.extend(App);var router=new VueRouter();//配置路由router.map(&#123; '/home': &#123; component: home &#125;, '/list': &#123; component: list &#125;, '/detail': &#123; component: detail &#125;&#125;);//设置默认情况下打开的页面router.redirect(&#123; '/':'home'&#125;);router.start(app,'#app');//暴露路由接口调试window.router = router; 关于vue-router的介绍，官方文档介绍很清楚，地址：http://router.vuejs.org/zh-cn/index.html。配置好路由后，需要将匹配好的组件正确的渲染到页面中，此时用到&lt;router-view&gt;&lt;/router-view&gt;，它基于Vue的动态组件系统，所以它会继承一个正常动态组件的很多特性。在这里我们用到两个： v-transition和transition-mode的完整支持，为了切换效果能正常工作，路由组件必须不是一个片段实例。 在路由的0.7.2+中支持keep-alive（关于keep-alive） 所以在app.vue写入：12345678&lt;template&gt; &lt;div class=\"main\"&gt; &lt;router-view keep-alive transition=\"fade\" transition-mode='out-in'&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 打开命令行启动webpack-dev-server：1$ webpack-dev-server --inline --hot 此时我们在页面中看到的页面就是home.vue 在home.vue中实现tab切换tab切换作为一个常见的效果，出现的频率很高，那么如何用vuejs写一个tab切换效果呢？利用当前被点击的tab是第几个，从而动态的切换相应的动态组件是vuejs实现切换的一种方式。动态组件的介绍如下：https://vuejs.org.cn/guide/components.html#动态组件。所以实现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt;&lt;div class=\"home\"&gt; &lt;div class=\"bd\" style=\"height: 100%;\"&gt; &lt;div class=\"weui_tab\"&gt; &lt;ul class=\"weui_navbar\"&gt; &lt;li class=\"weui_navbar_item\" v-for=\"tab in tabs\" :class=\"&#123;'weui_bar_item_on':$index===selected&#125;\" @click=\"choose($index)\"&gt;&#123;&#123;tab.tabName&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"weui_tab_bd\"&gt; &lt;component :is=\"currentView\" transition=\"fade\" transition-mode=\"out-in\"&gt;&lt;/component&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import tab_1 from './tab/tab_1.vue';import tab_2 from './tab/tab_2.vue';export default&#123; data()&#123; return&#123; tabs:[ &#123;tabName:'Vuejs'&#125;, &#123;tabName:'VueTab'&#125; ], selected:0, currentView:'view_0' &#125; &#125;, components:&#123; 'view_0':tab_1, 'view_1':tab_2 &#125;, methods:&#123; choose(index) &#123; this.selected=index; this.currentView='view_'+index; &#125; &#125;&#125;&lt;/script&gt; 两个动态组件为tab_1.vue和tab_2.vue。引入这两个模块，对外输出对组件的操作export default{}，在template模板中将动态组件加载进去，使用保留的&lt;component&gt;元素，动态地绑定它的is特性，从而根据不同的值动态的切换组件，在需要点击的tab导航上，需要v-for循环出两个导航，然后动态绑定class，根据当前点击的tab导航$index动态的切换class名:class=&quot;{&#39;weui_bar_item_on&#39;:$index===selected}&quot;，然后给li绑定click事件，从而让其在被点击时执行事件@click=&quot;choose($index)&quot;。由于默认情况下显示第一个组件且第一个tab变灰，所以在data设置默认值。为了切换有过渡，添加了transition=&quot;fade&quot; transition-mode=&quot;out-in&quot;并在css中设置动画的执行过程：12345678/*切换动画*/.fade-transition &#123; transition: opacity 0.3s ease;&#125;.fade-enter,.fade-leave &#123; opacity: 0;&#125; 利用v-link实现路由链接在组件中，用到了路由，在给a写路由链接时候要使用v-link而不是href。在带有v-link指令的元素，如果v-link对应的URL匹配当前路径，则该元素会被添加一个特定的class，默认为.v-link-active，这个默认值，我们可以通过在创建路由时指定linkActiveClass全局选项来自定义，也可以通过activeClass内联选项来单独制定：1&lt;a v-link=\"&#123;path:'/a',activeClass:'active'&#125;\"&gt;test&lt;/a&gt; 遇到的一些问题1.v-for循环插入图片在写循环插入图片的时候，写的代码如下：123&lt;div class=\"bio-slide\" v-for=\"item in items\"&gt; &lt;img src=\"&#123;&#123;item.image&#125;&#125;\"&gt;&lt;/div&gt; 此时在控制台会出现警告[Vue Warn]: src=&quot;&quot;: interpolation in &quot;src&quot; attribute will cause a 404 request. Use v-bind:src instead.这里意思是在src属性插值将导致404请求。使用v-绑定：src代替。所以替换成如下：123&lt;div class=\"bio-slide\" v-for=\"item in items\"&gt; &lt;img v-bind:src=\"item.image\"&gt;&lt;/div&gt; 这里需要主要，v-bind在写的时候不建议再用双花括号，根据官方的说法：1&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt; 这里href是参数，它告诉 v-bind指令将元素的 href特性跟表达式 url 的值绑定。可能你已注意到可以用特性插值href=&quot;&quot; 获得同样的结果：这样没错，并且实际上在内部特性插值会转为v-bind 绑定。 2.v-model的使用v-model用于在表单上创建双向绑定，只能用于&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;，如果用在其他元素中，则会在产生警告。 3.如何让组件的CSS样式只在组件中起作用在每一个vue组件中都可以定义各自的css，js，如果想写的css只对当前组件起作用，则在style中写入scoped，即：1&lt;style scoped&gt;&lt;/style&gt; 这样就完成了一个简单的基于Vue+webpack+vue-router的单页面应用，具体实现代码见github:vue_spa_demo。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mrzhang123.github.io/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://mrzhang123.github.io/tags/vue/"}],"keywords":[{"name":"Vue","slug":"Vue","permalink":"http://mrzhang123.github.io/categories/Vue/"}]},{"title":"利用webpack和vue实现组件化","slug":"webpack-vue-3","date":"2016-06-01T16:48:31.000Z","updated":"2016-07-14T04:06:56.965Z","comments":true,"path":"2016/06/02/webpack-vue-3/","link":"","permalink":"http://mrzhang123.github.io/2016/06/02/webpack-vue-3/","excerpt":"上一篇webpack+vue起步我们实现了用webpack打包vue的最基本用法，这篇我们将利用webpack+vue实现组件化 在vue中实现组件化用到了vue特有的文件格式.vue，在每一个.vue文件就是一个组件，在组件中我们将html，css，js全部写入，然后在webpack中配置vue-loader就可以了。","text":"上一篇webpack+vue起步我们实现了用webpack打包vue的最基本用法，这篇我们将利用webpack+vue实现组件化 在vue中实现组件化用到了vue特有的文件格式.vue，在每一个.vue文件就是一个组件，在组件中我们将html，css，js全部写入，然后在webpack中配置vue-loader就可以了。 建立vue组件在src目录下建立components文件夹，并在其中建立app.vue文件，这样我们项目的目录结构如下：12345678910|--dist //webpack打包后生成的文件夹| |--build.js|--node_modules //项目的依赖所在的文件夹|--src //文件入口| |--components //组件存放文件夹| |--app.vue //组件| |--main.js //主js文件|--index.html //主html文件|--package.json|--webpack.config.js //webpack配置文件 首先在index.hmtl中写入代码：1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;app&gt;&lt;/app&gt; &lt;script src=\"dist/build.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在编辑器中打开app.vue文件，写入如下代码：12345678910111213141516171819&lt;template&gt;&lt;div class=\"message\"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: 'Hello from vue-loader' &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.message&#123; color:red; font-size:36px; font-weight:blod;&#125;&lt;/style&gt; 在main.js中写入：1234567import Vue from 'vue'import App from './components/app.vue'new Vue(&#123; el: 'body', components:&#123;App&#125;&#125;); 这样运行命令webpack就可以看到效果了这里用到了ES6的模块儿—import，export export命令export命令用于规定模块的对外接口。一个模块就是一个独立文件。该文件内的所有变量外部都无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用export关键字对外暴露出该变量。例如：1234//export.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; 这样就可以对外输出三个变量。 import命令使用export对外暴露了接口后，其他js文件通过import命令加载这个模块文件。上面暴露的三个变量在另一个js文件中引入如下：12345//import.jsimport &#123;firstName,lastName,year&#125; from './export';function setName(element)&#123; element.textContent = firstName + ' ' + lastName;&#125; webpack的hot-reload前端自动刷新现在已经很常见了，即改变页面后，浏览器自动刷新，但是这个功能在我们做单页面应用时候会很不好用，所以，webpack支持hot-reload(热替换)，当我们修改模块时候不会页面不会刷新，会直接在页面中生效。 hot-reload的基础—webpack-dev-serverwebpack-dev-server支持两种模式的自动刷新页面： iframe模式（页面嵌入一个iframe并在其中呈现页面的变化） inline模式（一个小型的webpack-dev-server客户端会作为入口文件打包，这个客户端会在后端代码改变的时候刷新页面） iframe模式使用iframe模式无需额外的配置，在dos下输入命令1$ webpack-dev-server 在浏览器中输入 http://loacalhost:8080/webpack-dev-server/index.html inline模式在dos下输入命令1$ webpack-dev-server --inline --hot 启动服务器，在浏览器中打开 http://loacalhost:8080 就可以看到我们的页面，此时修改app.vue中的css，以及html中的文字，都可以看到在浏览器中立马呈现。关于webpack-dev-server的详细说明，可以参考官方文档或者博客WEBPACK DEV SERVER。 这里有一个问题需要说明下在很多文章中都说，修改app.vue文件中script标签中的msg文字，会在浏览器中立即呈现效果，但是事实上我在做demo的时候并没有出现这个效果，Google了很多，找到了答案，尤大说：“data是初始值，但热更新的时候会保留当前状态”，原问题及答案链接。 至此，关于webpack+vue的基本结束，虽然简单，但是由于在这个过程中也遇到一些坑，所以总结下，关于对vue的研究，这才只是个开始… 附：我的webpack配置文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var path = require('path');module.exports = &#123; entry: './src/main.js', output: &#123; path: './dist', publicPath:'dist/', filename: 'build.js' &#125;, //配置自动刷新,如果打开会使浏览器刷新而不是热替换 /*devServer: &#123; historyApiFallback: true, hot: false, inline: true, grogress: true &#125;,*/ module: &#123; loaders: [ //转化ES6语法 &#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/ &#125;, //解析.vue文件 &#123; test:/\\.vue$/, loader:'vue' &#125;, //图片转化，小于8K自动转化为base64的编码 &#123; test: /\\.(png|jpg|gif)$/, loader:'url-loader?limit=8192' &#125; ] &#125;, vue:&#123; loaders:&#123; js:'babel' &#125; &#125;, resolve: &#123; // require时省略的扩展名，如：require('app') 不需要app.js extensions: ['', '.js', '.vue'], // 别名，可以直接使用别名来代表设定的路径以及其他 alias: &#123; filter: path.join(__dirname, './src/filters'), components: path.join(__dirname, './src/components') &#125; &#125; &#125; package.json文件：1234567891011121314151617181920212223242526272829303132&#123; \"name\": \"webpackvue\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"vue.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"babel-core\": \"^6.9.1\", \"babel-loader\": \"^6.2.4\", \"babel-plugin-transform-runtime\": \"^6.9.0\", \"babel-preset-es2015\": \"^6.9.0\", \"babel-preset-stage-0\": \"^6.5.0\", \"babel-runtime\": \"^6.9.2\", \"css-loader\": \"^0.23.1\", \"file-loader\": \"^0.8.5\", \"style-loader\": \"^0.13.1\", \"url-loader\": \"^0.5.7\", \"vue\":\"^1.0.24\", \"vue-router\":\"^0.7.13\", \"vue-hot-reload-api\": \"^1.3.2\", \"vue-html-loader\": \"^1.2.2\", \"vue-loader\": \"^8.5.2\", \"vue-style-loader\": \"^1.0.0\", \"webpack\": \"^1.13.1\", \"webpack-dev-server\": \"^1.14.1\", \"webpack-merge\": \"^0.13.0\" &#125;&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mrzhang123.github.io/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://mrzhang123.github.io/tags/vue/"}],"keywords":[{"name":"Vue","slug":"Vue","permalink":"http://mrzhang123.github.io/categories/Vue/"}]},{"title":"webpack与vue起步","slug":"webpack-vue-2","date":"2016-05-31T13:37:08.000Z","updated":"2016-07-14T04:06:42.637Z","comments":true,"path":"2016/05/31/webpack-vue-2/","link":"","permalink":"http://mrzhang123.github.io/2016/05/31/webpack-vue-2/","excerpt":"记得第一次知道Vue.js是在勾三股四大大的微博，那时候他开始翻译vue的文档，从那时候开始到现在，看了几次vue的教程，每次都有更深的理解，因为之前并没有研究过angular等框架，所以对MVVM并不是很了解，但是经过这段时间对vuejs的一些研究，越来越懂了，这篇文章，只是对vuejs和webpack配合的非常基础的文章，我想随着我对vue的深入理解，会对组件化，模块化，MVVM有更深入的理解。 项目的创建1.新建项目文件夹，并在其中建立package.json123$ mkdir [project name]$ cd [project name]$ npm init","text":"记得第一次知道Vue.js是在勾三股四大大的微博，那时候他开始翻译vue的文档，从那时候开始到现在，看了几次vue的教程，每次都有更深的理解，因为之前并没有研究过angular等框架，所以对MVVM并不是很了解，但是经过这段时间对vuejs的一些研究，越来越懂了，这篇文章，只是对vuejs和webpack配合的非常基础的文章，我想随着我对vue的深入理解，会对组件化，模块化，MVVM有更深入的理解。 项目的创建1.新建项目文件夹，并在其中建立package.json123$ mkdir [project name]$ cd [project name]$ npm init 2.在项目目录下新建index.html1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue example&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; &lt;script src=\"dist/build.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; src文件夹，并在该文件夹下建立main.js1234567import Vue from 'vue'new Vue(&#123; el:'body', data:&#123; message:'test success!' &#125;&#125;); 设置webpack1.安装webpack，webpack-dev-server以及相关的loaders12345# 全局安装webpack，webpack-dev-server$ npm install -g webpack$ npm install -g webpack-dev-server# 为项目安装其他依赖$ npm i webpack-merge css-loader style-loader file-loader url-loader babel-core babel-loader babel-plugin-transform-runtime babel-preset-es2015 babel-preset-stage-0 babel-runtime vue vue-loader vue-html-loader vue-style-loader vue-hot-reload-api -D webpack-merge：开发环境和生产环节的webpaak配置文件的配置合并css-loader：编译写入cssstyle-loader：把编译后的css整合进htmlfile-loader：编译写入文件，默认情况下生成文件的文件名是文件名与MD5哈希值的组合vue：vue主程序vue-laoder：编译写入.vue文件vue-html-loader：编译vue的template部分vue-style-loader：编译vue的样式部分vue-hot-reload-api：webpack对vue实现热替换babel-core：ES2015编译核心babel-loader：编译写入ES2015文档babel-preset-es2015：ES2015语法babel-preset-stage-0：开启测试功能babel-runtime：babel执行环境 url-loader这里介绍下url-loader，这个loader实际上是对file-loader的封装https://github.com/webpack/url-loader比如CSS文件中有时候会这么写：123.demo&#123; background-image: url('a.png');&#125; 12345module:&#123; loaders:[ &#123;test:/\\.(png|jpg)$/,loader:'url-loader?limit=8192'&#125; ]&#125; 经过以上配置，当a.png小于8K就会自动将图片转换成base64编码，如果不小于，则不会转换。这里顺便提一句，在module配置的时候，loader的写法：123456789module:&#123; loaders:[ &#123;test:/\\.jade$/,loader:'jade'&#125; //这里配置了让webpack识别jade的loader，其他类似，比如.vue //用于css文件的loader有两种写法 &#123;test:/\\.css$/,loader:'style!css'&#125; &#123;test:/\\.css$/,loaders:['style','css']&#125; ]&#125; 2.配置webpack.config.js在根目录下建立webpack.config.js，配置如下：12345678910111213141516171819202122232425262728293031var path = require('path');module.exports = &#123; entry: './src/main.js', //定义webpack输出的文件，我们在这里设置了 让打包后生成的文件放在dist文件夹下的build.js文件中 output: &#123; path: './dist', publicPath:'dist/', filename: 'build.js' &#125;, module: &#123; loaders: [ //转化ES6语法 &#123; test: /\\.js$/, loader: 'babel', exclude: /node_modules/ &#125;, //图片转化，小于8K自动转化为base64的编码 &#123; test: /\\.(png|jpg|gif)$/, loader:'url-loader?limit=8192' &#125; ] &#125;, //这里用于安装babel，如果在根目录下的.babelrc配置了，这里就不写了 babel: &#123; presets: ['es2015','stage-0'], plugins: ['transform-runtime'] &#125;&#125; 特别说明如果要在.babelrc下配置babel，则需要在根目录下新建该文件，windows环境下，不能新建该txt文件然后改后缀，需要通过dos命令建立：1echo&gt;.babelrc 通过该命令就可以建立babelde配置文件，用编辑器打开，修改里面的内容为：1234&#123; \"presets\": [\"es2015\", \"stage-0\"], \"plugins\": [\"transform-runtime\"]&#125; 完成该配置我们在命令中运行1$ webpack 打开index.html就可以看到浏览器中看到我们刚刚写的文字至此我们实现了最基本的利用webpack打包vue，下一篇将讲解如何利用webpack+vue真正实现组件化。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mrzhang123.github.io/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://mrzhang123.github.io/tags/vue/"}],"keywords":[{"name":"Vue","slug":"Vue","permalink":"http://mrzhang123.github.io/categories/Vue/"}]},{"title":"Webpack初探","slug":"webpack-1","date":"2016-05-31T13:02:20.000Z","updated":"2016-06-07T17:17:02.691Z","comments":true,"path":"2016/05/31/webpack-1/","link":"","permalink":"http://mrzhang123.github.io/2016/05/31/webpack-1/","excerpt":"很早就听说webpack包管理工具，但是一直没有机会学习，这次又看到掘金上面有关于vue+webpack的初级文章，而且最近公司没什么事儿做，决定搞一下。在搞的过程中，虽然按照文章中写的去做，但是还是有很多问题，所以写下本文，总结下我遇到的问题以及解决办法。 包管理工具—webpackWebpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。","text":"很早就听说webpack包管理工具，但是一直没有机会学习，这次又看到掘金上面有关于vue+webpack的初级文章，而且最近公司没什么事儿做，决定搞一下。在搞的过程中，虽然按照文章中写的去做，但是还是有很多问题，所以写下本文，总结下我遇到的问题以及解决办法。 包管理工具—webpackWebpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。官网：http://webpack.github.io/对应各种不同文件类型的资源, Webpack 有对应的模块 loader比如 CoffeeScript 用的是coffee-loader, 其他还有很多:http://webpack.github.io/docs/list-of-loaders.html 安装 webpack的安装其实其实Google一搜一大把，但是为了完整性，还是写写吧。 webpack同样基于nodejs，所以我们需要先安装nodejs，然后再利用npm安装，webpack需要nodejs v0.6以上支持，建议使用最新的nodejs。首先全局安装webpack：1$ npm install webpack -g 或者将webpack安装到项目依赖中:1234# 进入项目目录# 确定已有package.json，没有就通过npm init创建# 安装webpack依赖$ npm install webpack --save-dev 使用首先创建一个静态页面index.html和一个JS入口文件entry.js： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\" src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12//entry.jsdocument.write('It works.'); 然后编译entry.js并打包到bundle.js：1$ webpack entry.js bundle.js 然后用浏览器打开index.html就可以看到It works.接下来添加一个模块module.js并修改入口entry.js：12345//module.jsmodule.exports='It work from module.js.';//entry.jsdocument.write('It works.');document.write(require('./module.js'));//添加模块 重新运行打包命令后就可以看到It work from module.js.这里我们用到了commonjs的模块写法：exports，require；前面已经说过，webpack作为打包工具，可以为commonjs，AMD，ES6模块打包。Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到bundle.js 。Webpack会给每个模块分配一个唯一的id并通过这个id索引和访问模块。在页面启动时，会先执行entry.js中的代码，其它模块会在运行require的时候再执行。这就是最基本的webpack的用法，当我第一次看到这个功能的时候，终于解决了曾经我对在页面中引用JS的一个困惑，即js文件a如何引用js文件b中的东西，webpack非常方便让我们做到了这一点。下一节，会结合Vuejs进行模块化开发，那时会用到更多的webpack的东西，并且会讲到关于ES6模块儿化的一些东西，加油！","categories":[{"name":"Vue","slug":"Vue","permalink":"http://mrzhang123.github.io/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://mrzhang123.github.io/tags/vue/"}],"keywords":[{"name":"Vue","slug":"Vue","permalink":"http://mrzhang123.github.io/categories/Vue/"}]},{"title":"慕课网---深入理解vertical-align总结","slug":"vertical-align-1","date":"2016-05-23T15:07:35.000Z","updated":"2016-08-02T16:34:53.886Z","comments":true,"path":"2016/05/23/vertical-align-1/","link":"","permalink":"http://mrzhang123.github.io/2016/05/23/vertical-align-1/","excerpt":"看了张鑫旭在慕课网关于vertical-align的讲解，感觉讲的挺深，所以总结了一下vertical-align的百分比值相对于line-height计算IE6/7下line-height不支持小数 vertical-align起作用的前提该属性应用于inline水平或者table-cell元素 inline水平inline:img,span,strong,em等inline-block:input,button（ie8+，ie6/7会把inline-block当作inline） table-cell元素td所以默认情况下支持vertical-align的有：图片，按钮，文字，单元格","text":"看了张鑫旭在慕课网关于vertical-align的讲解，感觉讲的挺深，所以总结了一下vertical-align的百分比值相对于line-height计算IE6/7下line-height不支持小数 vertical-align起作用的前提该属性应用于inline水平或者table-cell元素 inline水平inline:img,span,strong,em等inline-block:input,button（ie8+，ie6/7会把inline-block当作inline） table-cell元素td所以默认情况下支持vertical-align的有：图片，按钮，文字，单元格 抛出一个问题想实现图片的垂直居中12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width\"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; &lt;img src=\"http://www.insgeek.com/public/insgeek2.0/img/indexpec/enleft.jpg\" width='100' alt=\"\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 12345678p&#123; width:100%; height:200px; background-color: #ccc;&#125;img&#123; vertical-align:middle;&#125; 利用vertical-align：middle实现垂直居中，但是这里并没有按照我们想要的去做，解决办法： 1.给父元素添加line-height的值为的高度（ie7+都可以实现）123p&#123; line-height:200px;&#125; 2.给父元素添加display:table-celltable-cell元素的vertical-align只会作用于自身，里面的子元素设置不起作用12345p&#123; display:table-cell; /*把img的去掉*/ vertical-align:middle;&#125; vertical-align与line-height利用text-align:justify任意数目列表两端对齐效果1234.justify-fix&#123;display:inline-block;width:250px&#125;p&#123; background:#666;&#125; 123456789&lt;p style=\"text-align: justify\"&gt;&lt;img src=\"img/mm1.jpg\" width=\"250\" alt=\"\"&gt;&lt;img src=\"img/mm1.jpg\" width=\"250\" alt=\"\"&gt;&lt;img src=\"img/mm1.jpg\" width=\"250\" alt=\"\"&gt;&lt;img src=\"img/mm1.jpg\" width=\"250\" alt=\"\"&gt;&lt;i class=\"justify-fix\"&gt;&lt;/i&gt;&lt;i class=\"justify-fix\"&gt;&lt;/i&gt;&lt;i class=\"justify-fix\"&gt;&lt;/i&gt; &lt;/p&gt; 运行后红色虚线表示i标签的位置设置容器，p的行高为0123p&#123; line-height:0;&#125; 则出现如下情况： 为什么会出现这样的现象？首先看一个东西从CSS2的可视化格式模型文档中看到：‘inline-block’的基线是正常流中最后一个line box的基线，除非，这个line box里面既没有line boxes或者本身‘overflow’属性的计算值而不是‘visible’，这种情况下基线是margin第边缘举例说明：123456789101112&lt;style&gt; .dib-baseline&#123; display: inline-block; width: 150px; height: 150px; border: 1px solid #cad5eb; background-color: #f0f3f9; margin-top: 20px; &#125;&lt;/style&gt;&lt;span class=\"dib-baseline\"&gt;&lt;/span&gt;&lt;span class=\"dib-baseline\"&gt;dib-baseline&lt;/span&gt; 图1文档解释了该现象，因为前面的盒子没有任何字符，此时它的基线就是它的底边缘，后面的盒子有文字，所以该盒子的基线就是文字的基线，二者基线对齐，现成如此效果。如果把第二个盒子line-height:0，此时文字基线的位置，就是文字的垂直中心，所以：图2所以，以上情况下面那些空白，是由于本身后面两个图片是没有的，所以可以当作是空白字符（空格），即后面两个&lt;i&gt;是有字符的，而第一个&lt;i&gt;是没有字符的，所以和上面的那个例子一样，默认基线对齐，所以，会导致出现小的空隙（其本质和图2一样），要消除这个空隙，需要给i都添加空白字符（&nbsp;或者直接改变对齐方式，vertical-align：top / bottom）即可，而这个line-height：0可以不添加。 要消除需要给p标签（容器）设置：123456p&#123; line-height:0;&#125;.justify-fix&#123; vertical-align: bottom / top;&#125; 之后运行结果： vertical-align线性属性值1.vertical-align:bottom（top与之差不多）定义 inline / inline-block元素：元素底部和整行底部对齐。 table-cell元素：单元格底padding边缘和表格行的底部对齐 2.vertical-align:middle定义 inline / inline-block元素：元素的垂直中心点和父元素基线上1/2 x-height处对齐 table - cell元素：单元格填充盒子相对于外卖的表格行居中对齐 利用vertical-align：middle所实现的是近似垂直居中为什么是近似呢？答案就在于： inline / inline-block元素：元素的垂直中心点和父元素基线上1/2 x-height处对齐父元素基线上1/2 x-height处其实就是用line-height撑开后字符水平中心字符所在的水平中心线和经过line-height撑开后的水平中心线（vertical-algin：middle的水平中心线）不是一个中心线（具体演示看[4-1 vertical-align线性属性值]http://www.imooc.com/video/10403）因为字符，本身有个下沉的特性 那么如何实现完全垂直居中？给父元素设置1p&#123;font-size:0&#125; 这样元素的垂直中心点和父元素基线上1/2 x-height处就完全重合了但是这样会出现问题，如果我们在父级元素中有文字，那么设置font-size：0会导致文字无法显示，实现完全垂直居中的另一种方法是给图片（img）后面添加一个span,span设置为vertical-align：middle123p &#123; line-height:250px; &#125;img &#123; veritcal-align:middle; &#125;img+span &#123; veritcal-align:middle; &#125; vertical-align文本类属性值定义： vertical-align :text-top盒子的顶部和父级content area的顶部对齐 vertical-align：text-bottom 盒子的底部和父级content area的底部对齐 解释：content area就是只与父级font-size的大小有关，与行高，以及后面是否有inline-block元素的没有任何关系，但是vertical-align：middle / top / bottom都会被后面的inline-block水平元素影响。 用处：一般用于表情图片（或原始尺寸背景图标）与文字的对齐效果 输入理解vertical-align上标下标类—sub / superHTML中有原生的上下标标签，分别为：&lt;sup&gt; ,&lt;sub&gt;。利用原生的HTML获得的上下标文字大小是父元素75%左右。 定义：1.vertical-align：super提高盒子的基线到父级合适的上标基线位置。2.vertical-align：sub降低盒子的基线到父级合适的下标基线位置。这里的‘合适的上（下）标基线位置’，哪里合适，说不清 vertical-align前后不一的作用机制与示例 vertical-align所有的表现只当前元素和父级有关，前后并没有直接影响1.实现小图标和文字的对齐使用vertical-align负值，虽然图片文字对齐可以使用浮动实现的，但是尽量少用浮动，因为会破坏布局，使用vertical-align负值可以实现居中2.不定尺寸图片或多行文字的垂直居中,具体实现步骤如下：a.大小不固定的图片垂直居中 主体元素inline-block化； 0宽度100%高度辅助元素； vertical-align:middle；1&lt;p&gt;&lt;img width=\"30%\" src=\"./111.jpg\"&gt;&lt;i&gt;&lt;/i&gt;&lt;/p&gt; 123456789101112131415161718p&#123; width: 500px; height: 200px; background-color: yellowgreen;&#125;/*主体元素inline-block化img本身是inline，但是里面的content为inline-block*/img&#123; width: 40%; vertical-align:middle; &#125;/*宽度为0，高度100%的辅助元素*/i &#123; display: inline-block; height: 100%; vertical-align:middle;&#125;/*给以上 img 和 i 元素添加 vertical-align:middle; */ 实现垂直居中，效果如下：b.大小不固定的文字垂直居中：1234&lt;p&gt; &lt;span&gt;测试文字垂直居中&lt;br/&gt;测试文字垂直居中&lt;br/&gt;测试文字垂直居中&lt;br/&gt;测试文字垂直居中&lt;br/&gt;测试文字垂直居中&lt;br/&gt;测试文字垂直居中&lt;br/&gt;测试文字垂直居中&lt;br/&gt;测试文字垂直居中&lt;/span&gt; &lt;i&gt;&lt;/i&gt; &lt;/p&gt; 1234567891011121314p&#123; width: 500px; height: 200px; background-color: yellowgreen;&#125;span&#123; display: inline-block; vertical-align:middle; &#125;i&#123; display: inline-block; height: 100%; vertical-align:middle;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/categories/CSS/"}]},{"title":"Gulp+BroserSync实现浏览器自动刷新","slug":"gulp-broserSync","date":"2016-05-16T14:10:39.000Z","updated":"2016-08-02T16:36:13.655Z","comments":true,"path":"2016/05/16/gulp-broserSync/","link":"","permalink":"http://mrzhang123.github.io/2016/05/16/gulp-broserSync/","excerpt":"&emsp;&emsp;在写前端代码的时候，我们为了看效果，需要一直按F5进行刷新，这样做很繁琐而且非常浪费时间，在网上搜过后发现很多关于自动刷新的办法，这里我介绍的是基于gulp和broserSync实现浏览器的自动刷新，即只要编辑器保存，浏览器就会自动刷新。&emsp;&emsp;那么gulp，broserSync是什么呢？ Gulp&emsp;&emsp;Gulp是一个前端自动化工具，基于nodejs，和grunt差不多，但是比grunt语法更加简单，语法更加自然。在gulp的插件中，我们可以找到自动刷新，压缩图片/代码/等等各类工具，方便我们的使用，并且gulp的任务是流（pipe），即一个任务完成后，紧接的另一个任务开始进行。gulp的使用如下： 1.安装gulp 全局安装gulp： 1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： 1$ npm install --save-dev gulp 生成package.json 1$ npm init","text":"&emsp;&emsp;在写前端代码的时候，我们为了看效果，需要一直按F5进行刷新，这样做很繁琐而且非常浪费时间，在网上搜过后发现很多关于自动刷新的办法，这里我介绍的是基于gulp和broserSync实现浏览器的自动刷新，即只要编辑器保存，浏览器就会自动刷新。&emsp;&emsp;那么gulp，broserSync是什么呢？ Gulp&emsp;&emsp;Gulp是一个前端自动化工具，基于nodejs，和grunt差不多，但是比grunt语法更加简单，语法更加自然。在gulp的插件中，我们可以找到自动刷新，压缩图片/代码/等等各类工具，方便我们的使用，并且gulp的任务是流（pipe），即一个任务完成后，紧接的另一个任务开始进行。gulp的使用如下： 1.安装gulp 全局安装gulp： 1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： 1$ npm install --save-dev gulp 生成package.json 1$ npm init 注意：&emsp;&emsp;这里官网只是写让这么安装，但是需要注意，两个安装不是第一步第二步，而是第一种方式或者第二种方式，两种方式任选其一。第一种安装方式是全局安装，即安装后，整个电脑无论哪个项目都可以使用。对应的，第二个表示安装到对应项目中，即如果在window的cmd命令行进入对应项目A的目录，则运行npm install –save-dev gulp后，安装的gulp只能在该文件夹下使用，其他文件夹下的其他文件都无法使用。&emsp;&emsp;其实不只是gulp，gulp的插件也是这样，要么全局安装，要么安装在项目中。一般情况下，gulp会全局安装，但是由于每个项目用到的gulp插件不同，所以可能需要局部安装gulp插件。&emsp;&emsp;安装完成gulp之后，会在安装gulp的文件夹下生成node_modules文件夹。此时，在与该文件夹同层创建gulpfile.js这就是用于配置gulp插件的文件。 2.恢复gulp&emsp;&emsp;随着我们gulp插件的改变，package.json会自动变化，同时我们的配置文件gulpfile.js也会对应变化（自己手动配置）。他们可以把我们安装的gulp给备份，如果我们在电脑A中安装完我们的工具，然后换了一台电脑B，我们只需要把电脑A中package.json与gulpfile.js复制到B电脑，然后在安装完gulp后，运行1$ npm install gulp就会自动把我们在package.json中的所有gulp插件全部安装回来，非常方便。 broserSync&emsp;&emsp;broserSync（以下简称bs）是一款非常优秀的自动刷新工具，本身可以独立使用，也可以配合gulp或者grunt一起使用，非常不错的一款插件。&emsp;&emsp;当你改变代码的时候，BrowserSync会重新加载页面，或者如果是css文件，会直接添加进css中，页面并不需要再次刷新。这项功能在网站是禁止刷新的时候是很有用的。假设你正在开发单页应用的第4页，刷新页面就会导致你回到开始页。BrowserSync会直接将需要修改的地方添加进CSS，就不用再点击回退。同时，BrowserSync也可以在不同浏览器之间同步点击翻页、表单操作、滚动位置。你可以在电脑和iPhone上打开不同的浏览器然后进行操作。所有设备上的链接将会随之变化，当你向下滚动页面时，所有设备上页面都会向下滚动（通常还很流畅！）。当你在表单中输入文本时，每个窗口都会有输入。当你不想要这种行为时，也可以把这个功能关闭。&emsp;&emsp;实际上bs对于gulp并不算是一种插件，因为bs并不像一个插件一样操作文件。然而，npm上的bs模块能在gulp上被直接调用。 1.安装broserSync进入需要使用bs的目录，运行：1$ npm install --save-dev broser-sync 2.配置broserSyncbs本身可以打开本地静态服务器，也可以代理像wamp这样的服务器。 2.1 代理其他服务器打开我们新建的gulpfile.js，配置如下：1234567891011121314151617181920212223242526/*browserSync*/const gulp = require('gulp');const browserSync = require('browser-sync').create();gulp.task(\"watch\",function()&#123; browserSync.init(&#123; /*这里的files写的是需要监控的文件的位置*/ files:[ \"./Home/View/PC/**/*.html\", \"./public/group/css/*.css\", \"./public/group/js/*.js\" ], logLevel: \"debug\", logPrefix:\"insgeek\", /*这里的proxy写的是需要代理的服务器，我自己的wamp启动的是localhost:80*/ proxy:\"localhost:80\", ghostMode: &#123; clicks: true, forms: true, scroll: true &#125;, /*这里写的是代理后，bs在哪个端口打开*/ port: 81, /*这里设置的是bs运行时打开的浏览器名称*/ browser: \"chrome\" &#125;);&#125;); 2.2 启动静态服务器123456789101112131415161718192021222324252627const gulp = require('gulp');const browserSync = require('browser-sync').create();const reload = browserSync.reload;/*实时监控*/gulp.task(\"watch\", function() &#123; browserSync.init(&#123; files: [ \"./work/*/*.html\", \"./work/*/*.css\", \"./work/*/*.js\" ], logLevel: \"debug\", logPrefix: \"insgeek\", server: &#123; /*这里写的是html文件相对于根目录所在的文件夹*/ baseDir: \"./work/statement\" /*这里如果不写，默认启动的是index.html，如果是其他名字，需要这里写*/ // index: \"insurance_template_statement.html\" &#125;, ghostMode: &#123; clicks: true, forms: true, scroll: true &#125;, browser: \"chrome\" &#125;);&#125;); 完成上述配置后，可以在cmd命令行切换到工作目录，运行gulp watch启动broserSync。","categories":[{"name":"前端工具","slug":"前端工具","permalink":"http://mrzhang123.github.io/categories/前端工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://mrzhang123.github.io/tags/gulp/"}],"keywords":[{"name":"前端工具","slug":"前端工具","permalink":"http://mrzhang123.github.io/categories/前端工具/"}]},{"title":"text-algin:justify实现文本两端对齐","slug":"text-algin","date":"2016-05-10T16:25:18.000Z","updated":"2016-08-02T16:36:37.412Z","comments":true,"path":"2016/05/11/text-algin/","link":"","permalink":"http://mrzhang123.github.io/2016/05/11/text-algin/","excerpt":"最近在写页面的时候遇到了一个问题—当行文本双端对齐，大家都知道CSS属性中有一个“text-align:justify”，但是这个属性使用的时候，要求还是挺多的，尤其是要实现单行文本双端对齐。关于两端对齐，大漠和张鑫旭的博客中都有文章讲，非常不错，推荐给大家：display:inline-block/text-align:justify下列表的两端对齐布局Text-align:Justify和RWD text-align:justify与text-align-last:justify1.text-alignMDN中这样介绍到：“text-align CSS属性定义行内内容（例如文字）如何相对它的块父元素对齐。text-align并不控制块元素自己的对齐，只控制它的行内内容的对齐。”从这里可以看出，控制文本居中对齐直接写text-align:justify就可以。但是这对于多行文本（即有文本换行）除了最后一行都可以实现两端对齐，最后一行依旧左对齐。所以就需要控制最后一行文本对齐方式的CSS属性：text-align-last。","text":"最近在写页面的时候遇到了一个问题—当行文本双端对齐，大家都知道CSS属性中有一个“text-align:justify”，但是这个属性使用的时候，要求还是挺多的，尤其是要实现单行文本双端对齐。关于两端对齐，大漠和张鑫旭的博客中都有文章讲，非常不错，推荐给大家：display:inline-block/text-align:justify下列表的两端对齐布局Text-align:Justify和RWD text-align:justify与text-align-last:justify1.text-alignMDN中这样介绍到：“text-align CSS属性定义行内内容（例如文字）如何相对它的块父元素对齐。text-align并不控制块元素自己的对齐，只控制它的行内内容的对齐。”从这里可以看出，控制文本居中对齐直接写text-align:justify就可以。但是这对于多行文本（即有文本换行）除了最后一行都可以实现两端对齐，最后一行依旧左对齐。所以就需要控制最后一行文本对齐方式的CSS属性：text-align-last。 2.text-align-lasttext-align-last 属性规定如何对齐文本的最后一行。但是这里注意一点text-align-last 属性只有在 text-align 属性设置为 “justify” 时才起作用。所以，利用这个属性就可以控制最后一行文本的对齐方式。我们可以想象，如果是单行文本，就可以当作最后一行文本处理，直接设置text-align-last:justify来实现当行文本两端对齐，可惜的是，这样的方法兼容性并不好。 利用CSS实现兼容性较好的两端对齐从上面的分析可以知道，如果文本出现换行，则除最后一行的所有文本都会实现两端对齐。这时我们想到利用::after伪类，给元素最后设置一个看不见的内联元素，并设置宽度为100%，就可以让我们可以看到的单行文本让浏览器认为是多行文本，从而实现单行文本的两端对齐。具体实现代码如下：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width\"&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"line\"&gt; &lt;div class=\"public\"&gt;啊啊&lt;/div&gt; &lt;b&gt;:&lt;/b&gt; &lt;b&gt;aaaaaa&lt;/b&gt;&lt;/div&gt;&lt;div class=\"line\"&gt; &lt;div class=\"public\"&gt;啊啊啊啊啊&lt;/div&gt; &lt;b&gt;:&lt;/b&gt; &lt;b&gt;aaaaaa&lt;/b&gt;&lt;/div&gt;&lt;div class=\"line\"&gt; &lt;div class=\"public\"&gt;啊啊啊啊&lt;/div&gt; &lt;b&gt;:&lt;/b&gt; &lt;b&gt;aaaaaa&lt;/b&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021.line&#123; width:100%; height:15px; margin:5px; background-color: #ccc;&#125;.public&#123; width:80px; height:100%; display:inline-block; text-align: justify; vertical-align:top; background-color: #aaa;&#125;.public::after&#123; content:\"\"; display: inline-block; width:100%; overflow:hidden; height:0;&#125; 运行结果：","categories":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/categories/CSS/"}]},{"title":"利用CSS3新单位rem实现响应","slug":"file-rem","date":"2016-04-26T14:49:25.000Z","updated":"2016-08-02T16:37:01.221Z","comments":true,"path":"2016/04/26/file-rem/","link":"","permalink":"http://mrzhang123.github.io/2016/04/26/file-rem/","excerpt":"做移动端的响应方法有很多，但是我喜欢用CSS3的新单位rem，这个单位非常好用（有个比它还好用的单位vh，不过兼容性太差，不考虑了），根据不同屏幕，设置不同的基准值，从而实现适配各个屏幕尺寸的移动设备。慕课网有一套非常不错的讲关于rem的视频，这里推荐给大家http://www.imooc.com/learn/494。rem—-CSS3中新增的单位，兼容性还不错，常用于移动端实现字体的响应，与em不同，rem根据根元素的font-size计算，所以要利用rem实现适配各个屏幕的大小，就需要根据不同的屏幕设置根元素不同的font-size的值。所以我们需要做下面的一些工作。 1.获取浏览器的宽高（对于移动设备就是设备的宽度）代码如下：1234567891011var pageWidth=window.innerWidth;var pageHeight=window.innerHeight;if(typeof pageWidth !=='number')&#123; if(document.compatMode==='CSS1Compat')&#123; pageWidt=document.documentElement.clientWidth; pageHeight=document.documentElement.clientHeight; &#125;else&#123; pageWidt=document.body.clientWidth; pageHeight=document.body.clientHeight; &#125;&#125;","text":"做移动端的响应方法有很多，但是我喜欢用CSS3的新单位rem，这个单位非常好用（有个比它还好用的单位vh，不过兼容性太差，不考虑了），根据不同屏幕，设置不同的基准值，从而实现适配各个屏幕尺寸的移动设备。慕课网有一套非常不错的讲关于rem的视频，这里推荐给大家http://www.imooc.com/learn/494。rem—-CSS3中新增的单位，兼容性还不错，常用于移动端实现字体的响应，与em不同，rem根据根元素的font-size计算，所以要利用rem实现适配各个屏幕的大小，就需要根据不同的屏幕设置根元素不同的font-size的值。所以我们需要做下面的一些工作。 1.获取浏览器的宽高（对于移动设备就是设备的宽度）代码如下：1234567891011var pageWidth=window.innerWidth;var pageHeight=window.innerHeight;if(typeof pageWidth !=='number')&#123; if(document.compatMode==='CSS1Compat')&#123; pageWidt=document.documentElement.clientWidth; pageHeight=document.documentElement.clientHeight; &#125;else&#123; pageWidt=document.body.clientWidth; pageHeight=document.body.clientHeight; &#125;&#125; 1.1 window.innerWidth与document.documentElement.clientWidth通过测试发现，在IE9+，chrome，firefox下利用window.innerWidth与document.documentElement.clientWidth都可以获取到浏览器的宽高，但是他们有区别： window.innerWidth获取到的宽度是把右侧滚动条算在内的宽度 document.documentElement.clientWidth获取到的宽度是把右侧滚动条的宽度不算在内的宽度 但是，window.innerWidth支持的是IE9+，到IE8以前就会输出undefined，而document.documentElement.clientWidth可以支持IE7（在IE模拟器中，没有IE6，到IE5就只能输出0了），在《javascript高级程序设计》（第三版）中这样写道：“在 IE6 中，这些属性必须在标准模式下才有效；如果是混杂模式，就必须通过 document.body.clientWidth 和 document.body. clientHeight 取得相同信息。”所以document.body.clientWidth;用于混杂模式，在标准模式下只需要document.documentElement.clientWidth即可。 1.2 如何判断浏览器处于什么模式？Javascript提供了方法12345if(document.compatMode==='CSS1Compat')&#123; alert('标准模式');&#125;else if(document.compatMode==='BackCompat')&#123; alert('混杂模式');&#125; 2.计算rem基准值通过上面代码可以拿到浏览器窗口（也就是document）的宽度，这样就可以计算根元素的基准值了，计算公式如下：123var fontSize=pageWidth / 20;var html=document.querySelectorAll('html')[0];html.style.fontSize=fontSize; 通过以上代码就实现了给根元素设置基准fontSize。 3.将PSD中测量出的值换算成rem公司设计师给的PSD的基准宽度为720px,所以我在布局的时候常常使用nexus 5作为移动端设备去测试，因为它的宽度是360px，与720px刚好是2倍的关系，根据这个2倍的关系，所以换算步骤如下： PSD设计图中测量出来的尺寸为m px，则放在我移动设备中需要写的尺寸为m/2 px 将px换算为rem，由于在360px的移动设备下，font-size基准值为360 / 20 = 18px，所以px=&gt;rem过程为：rem = m / 2 / 18 = m / 36; 通过以上计算就将PSD中的px转换为移动设备中的rem，这样就可以实现对各个移动设备的适配。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/tags/CSS/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://mrzhang123.github.io/categories/CSS/"}]},{"title":"文件上传（二）---新XMLHttpRequest实现带进度条文件上传","slug":"fileupload2","date":"2016-04-14T15:10:58.000Z","updated":"2016-08-02T16:37:17.931Z","comments":true,"path":"2016/04/14/fileupload2/","link":"","permalink":"http://mrzhang123.github.io/2016/04/14/fileupload2/","excerpt":"前几天搞得那个文件上传，最近工作不太忙，又开始完善。这次主要添加了文件上传的进度部分，主要用到的则是XMLHttpRequest2的progress，由于我读的是《javascript高级程序设计》（第三版），这里我遇到一个关于progeress事件的坑，后面详细解答。 创建XMLHttpRequest对象首先说说XMLHttpRequest，在IE7+浏览器中，只需要new一个XMLHttpRequest对象即可：1let xhr=new XMLHttpRequest(); 由于现在淘宝都不再支持IE6以及7，所以这里不考虑IE7及以下浏览器关于xhr的创建方法。","text":"前几天搞得那个文件上传，最近工作不太忙，又开始完善。这次主要添加了文件上传的进度部分，主要用到的则是XMLHttpRequest2的progress，由于我读的是《javascript高级程序设计》（第三版），这里我遇到一个关于progeress事件的坑，后面详细解答。 创建XMLHttpRequest对象首先说说XMLHttpRequest，在IE7+浏览器中，只需要new一个XMLHttpRequest对象即可：1let xhr=new XMLHttpRequest(); 由于现在淘宝都不再支持IE6以及7，所以这里不考虑IE7及以下浏览器关于xhr的创建方法。 open()方法在使用XHR对象时候，第一个方法是open()方法，它接受3个参数： 要发送的请求的类型（”get”、”post”等）； 请求的URL； 是否异步发送请求的布尔值。例如：12let xhr=new XMLHttpRequest();xhr.open('get','example.php',false); 以上代码会启动一个针对example.php的GET请求。这里需要注意两点： URL相对于执行代码的当前页面； 调用open()方法并不会真正发送请求，只是启动一个请求以备发送 sned()方法send()方法接收一个参数，即要作为请求主题发送的数据。如果不需要通过请求主题发送数据，则传入null。在发送数据收到响应后，响应的数据会自动填充XHR对象的属性，相关属性如下： responseText：作为响应主题被返回的文本； responseXML：如果响应的内容类型是”text/xml”或者”application/xml”，则这个属性中将保存包含着响应数据的XML DOM文档； status：响应HTTP状态； statusText：响应HTTP状态的说明。 在接收到响应后，第一步是检查 status 属性，以确定响应已经成功返回。一般来说，可以将 HTTP状态代码为 200作为成功的标志。此时，responseText 属性的内容已经就绪，而且在内容类型正确的情况下，responseXML也应该能够访问了。此外，状态代码为304 表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本。由于我们用XHR对象常常是为了异步传输，所以—可以检测 XHR 对象的readyState 属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下： 0：未初始化。尚未调用 open()方法。 1：启动。已经调用 open()方法，但尚未调用 send()方法。 2：发送。已经调用 send()方法，但尚未接收到响应。 3：接收。已经接收到部分响应数据。 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。 必须在调用 open()之前指定 onreadystatechange事件处理程序才能确保跨浏览器兼容性。所以，实现代码如下：1234567891011 var xhr = new XMLHttpRequest();//必须在open之前指定onreadystatechange才能保证跨浏览器兼容性！！！！xhr.onreadystatechange=function () &#123; if(xhr.readyState==4)&#123; if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||xhr.status==304)&#123; alert(xhr.responseText); &#125;else&#123; alert('请求失败'+xhr.status); &#125; &#125;&#125;; 所以利用以上代码就可以实现文件是上传成功还是失败。 XMLHttpRequest2级的进度事件XHR2有如下6个进度事件： loadstart：在接收到响应数据的第一个字节时触发。 progress：在接收响应期间持续不断地触发。 error：在请求发生错误时触发。 abort：在因为调用 abort()方法而终止连接时触发。 load：在接收到完整的响应数据时触发。 loadend：在通信完成或者触发 error、abort 或 load 事件后触发。 以上事件触发顺序如下：laodstart =&gt; progress =&gt; error =&gt; abort/load =&gt; loadend 关于progress事件中上传与下载的事件这里就是我遇到的坑，在《javascript高级程序设计》中并没有说清楚，让我感到困惑，在原书中581页这么描写：“onprogress事件处理程序会接收到一个 event 对象，其 target 属性是 XHR 对象，但包含着三个额外的属性：lengthComputable、position 和 totalSize。其中，lengthComputable 是一个表示进度信息是否可用的布尔值，position 表示已经接收的字节数，totalSize 表示根据Content-Length 响应头部确定的预期字节数。”而实际上表示总字节数的属性是total，表示已经传输的字节数是load属性。XHR2传输数据有一个progress事件，用来返回进度信息，它分成上传和下载两种情况，下载的progress事件属于XMLHttpRequest对象，而上传的progress事件属于XMLHttpRequest.upload对象。首先定义传输文件的函数：123456function percentFun(event)&#123; if (event.lengthComputable) &#123; /*event.total是需要传输的总字节数，event.load是已经传输的字节数，如果event.lengthComputable!=true,则event.total=0*/ var percent = event.loaded / event.total; &#125;&#125; 如果需要显示进度，则分别如下：1234/*下载的进度*/xhr.onprogress = percentFun;/*上传的进度*/xhr.upload.onprogress = percentFun; 基于以上几点，实现了上传进度显示，具体代码如下：12345678910111213141516171819202122232425262728293031323334353637addEvent(button,'click',function () &#123; if(filesArray.length!=0)&#123; var data=new FormData(); var i=0; while(i&lt;filesLen)&#123; data.append('file'+i,filesArray[i]); i++; &#125; var xhr = new XMLHttpRequest(); //必须在open之前指定onreadystatechange才能保证跨浏览器兼容性！！！！ xhr.onreadystatechange=function () &#123; if(xhr.readyState==4)&#123; if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||xhr.status==304)&#123; //console.log(xhr.responseText); &#125;else&#123; alert('请求失败'+xhr.status); &#125; &#125; &#125;; xhr.upload.onprogress=function (event) &#123; var e=event||window.event; var percentComplete = Math.ceil((e.loaded / e.total)*100); var progressFont=document.querySelectorAll('.progress-font'); for(let i=0;i&lt;filesArray.length;i++)&#123; ThumbnailArray[i].innerHTML=percentComplete +'%'; &#125; &#125; /*上传完成后滞空数组，保证下次上传不会重复上传*/ xhr.upload.onload=function () &#123; filesArray=[]; ThumbnailArray=[]; alert('上传完成，数组置空'); &#125; xhr.open('post','uploader.php',true); xhr.send(data); &#125; &#125;);","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}],"tags":[{"name":"H5 file，canvas","slug":"H5-file，canvas","permalink":"http://mrzhang123.github.io/tags/H5-file，canvas/"}],"keywords":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}]},{"title":"初探ES6——轮播图实践总结","slug":"es6-Practice","date":"2016-04-10T16:10:54.000Z","updated":"2016-08-02T16:37:36.152Z","comments":true,"path":"2016/04/11/es6-Practice/","link":"","permalink":"http://mrzhang123.github.io/2016/04/11/es6-Practice/","excerpt":"&emsp;&emsp;最近因为同学的一个轮播图不会写，让我萌生了用ES6写一个轮播图的想法（本人喜欢这些玩儿一些新的东西），以前就知道ES6，但是一直没有学，现在终于下决心学了，借助阮一峰老师的书ECMAScript 6 入门 和Youtube上面老外的视频学习ES6非常不错。阮一峰老师的书写的非常详细，推荐想学习的ES6的同学仔细看看。本篇文章会总结在实践中用到的ES6的知识。 模板字符串这是我非常喜欢的ES6的特点之一，非常直观的反应出变量和字符串之间的关系，在ES5中，如果我们想在字符串中添加变量，需要用如下写法：12345animate(box, 'translate(-' + itemWidth * num + 'px,0)', 1000, function () &#123; box.style.transitionDuration = ''; box.style.transform = 'translate(-800px,0)'; flag = true;&#125;); 现在用ES6的模板字符串，可以直接把字符串和变量相结合，更加易懂。12345animate(box, `translate(-$&#123;itemWidth*num&#125;px,0)`, 1000, function() &#123; box.style.transitionDuration = ''; box.style.transform = `translate(-$&#123;itemWidth*(item.length-2)&#125;px,0)`; flag = true;&#125;);","text":"&emsp;&emsp;最近因为同学的一个轮播图不会写，让我萌生了用ES6写一个轮播图的想法（本人喜欢这些玩儿一些新的东西），以前就知道ES6，但是一直没有学，现在终于下决心学了，借助阮一峰老师的书ECMAScript 6 入门 和Youtube上面老外的视频学习ES6非常不错。阮一峰老师的书写的非常详细，推荐想学习的ES6的同学仔细看看。本篇文章会总结在实践中用到的ES6的知识。 模板字符串这是我非常喜欢的ES6的特点之一，非常直观的反应出变量和字符串之间的关系，在ES5中，如果我们想在字符串中添加变量，需要用如下写法：12345animate(box, 'translate(-' + itemWidth * num + 'px,0)', 1000, function () &#123; box.style.transitionDuration = ''; box.style.transform = 'translate(-800px,0)'; flag = true;&#125;); 现在用ES6的模板字符串，可以直接把字符串和变量相结合，更加易懂。12345animate(box, `translate(-$&#123;itemWidth*num&#125;px,0)`, 1000, function() &#123; box.style.transitionDuration = ''; box.style.transform = `translate(-$&#123;itemWidth*(item.length-2)&#125;px,0)`; flag = true;&#125;); 是不是非常直观方便，从上面的两个简单示例中可以看出，在ES6中，字符串用反引号（``）标识，这一点需要知道。还有一个特点，模板字符串可以输出折行的字符串，这在ES5传统字符串中是无法做到的，必须借助（\\n），且不能在书写时候写入回车，但是在ES6的字符串模板中，可以直接写入回车，空格，然后在字符串输出时候直接输出，非常方便。123456789let myString=`abcdeffff fas`;console.log(myString);/*输出abcdeffff fas*/ 对函数的扩展1.给函数设置默认值在对函数的扩展中，添加了一项给函数设置默认值的功能，这个功能可以说是非常赞的。是否记得我们在ES5中是怎么给函数设置默认值？123456function test(a,b,c)&#123; var a=a||10; var a=b||15; var c=c||20; console.log(a+b+c);&#125; 这里我们设置默认值，可以达到自己的预期效果，直到有一天，我们把a=0传入，这时候，我们这么写就不对了，对于程序来说，0就是false，所以a会取默认值10，从而达不到我们预期的效果。但是ES6为我们提供非常好的设置默认值的方式。上面的代码可以改写成下面的这样：123function test(a=10,b=15,c=20)&#123; console.log(a+b+c);&#125; 2.箭头函数了解Coffescript的同学应该清楚，Cofficescript的强大之处在于它的无处不在的箭头函数，写起来非常爽，现在，ES6正式引入箭头函数，让我们的程序可以得到简化，例如：123456//ES5的写法var test = function (a,b)&#123; return a+b;&#125;//ES6的箭头函数var test2 = test(a,b)=&gt;a+b; 在写轮播时候，需要鼠标移动到下面的这个小圆点在小圆点类数组对象中是第几个，从而才能让图运动到正确位置，在ES5的时候，我们需要给当前这个对象添加属性，写起来比较繁琐，写法如下：1234567var liList = document.querySelectorAll('li');for(var i=0;i&lt;liList.length;i++)&#123; liList[i].index=i; liList[i].addEventListener('mouseenter',function()&#123; console.log(this.index); &#125;,false);&#125; 这个this.index属性就是当前的鼠标放上去的元素的索引，然后根据这个索引去得到当前的元素。但是在ES6中，我们可以直接使用箭头函数以及在数组中新引入的findIndex来找到当前的活动元素的索引，代码如下：12345678let liList = document.querySelectorAll('li');let ArrayliList=Array.form(liList);for(var i=0;i&lt;liList.length;i++)&#123; liList[i].index=i; liList[i].addEventListener('mouseenter',function()&#123; let thisIndex = ArrayliList.findIndex((n) =&gt; n == this); &#125;,false);&#125; 以上代码得到的thisIndex就是当前鼠标放上去的索引，这里我对箭头函数中n这个参数的理解是，传入参数n后会遍历数组中的对象，从而找到与this相等的那个对象，然后返回它的索引，这里用到Array.from()，这是一个ES6中数组中新增的方法，可以将类数组转换成数组。 ES6的for…of循环上面的JS代码循环用了for，其实可以用ES6中的for…of循环去代替，这样写法更加简洁。是否记得JS中的for…in循环，这个循环可以循环键值对中的键，但是无法循环值，而for…of的出现正是为了弥补它的不足，for…of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、Generator对象，以及字符串。所以我们可以利用该循环替代for循环，但是这里要注意一点如果直接用for…of循环，在chrome49下会报错，官方已证实这是chrome49的BUG，将会在chrome51中修复，所以我在写的时候，利用Array.from()将NodeList对象转换为数组，这样可以放心操作，代码如下：1234567let liList = document.querySelectorAll('li');let ArrayliList=Array.form(liList);for(let li of liList)&#123; li.addEventListener('mouseenter',function()&#123; let thisIndex = ArrayliList.findIndex((n) =&gt; n == this); &#125;,false);&#125; 是不是非常简洁:)以上就是最近几天对ES6的初探的总结，感觉仅仅只是这些就已经让我感受到ES6的魅力了，接下来，我会再做几个demo，慢慢去熟悉这个新的但是非常好玩儿的ES6。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/tags/Javascript/"}],"keywords":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}]},{"title":"文件上传（一）---H5 file API，canvas","slug":"H5File","date":"2016-03-31T15:35:12.000Z","updated":"2016-08-02T16:38:04.141Z","comments":true,"path":"2016/03/31/H5File/","link":"","permalink":"http://mrzhang123.github.io/2016/03/31/H5File/","excerpt":"&emsp;&emsp;最近公司让调研关于webUploader的图片上传中能否压缩，能否实现图片的格式转换，如果能如何实现，经过调研，这个插件可以实现文件的压缩，但是不能实现图片的格式转换，同时在调研过程中，知道了很多新的东西，H5 file API，canvas，等等，所以有了自己写一个文件上传来熟悉这些东西，所以有了本篇文章。 一.做好HTML，CSS样式这里很简单，就是写一个HTML+CSS的文件，让我们的上传看起来像那么回事儿，这里不细说，代码如下： html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;fileUploader&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./index.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"upbox\"&gt; &lt;h1&gt;测试&lt;/h1&gt; &lt;input id=\"uploader\" type=\"file\" multiple=\"multiple\" name=\"file\" accept=\"image/*\"&gt; &lt;/div&gt; &lt;a id=\"test\" href=\"\"&gt;点击选择上传图片&lt;/a&gt; &lt;button type=\"button\" id=\"button\"&gt;上传&lt;/button&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.css1234567.upbox&#123;width: 100%;height: 500px;border: 3px dashed #000;position: relative;&#125;#uploader&#123;display: block;width: 100%;height: 100%;opacity: 0;position: absolute;left: 0;top: 0;cursor: pointer;&#125;h1&#123;position: absolute;left: 45%;top: 40%;&#125;button&#123;width: 100px;height: 50px;float: right;&#125;.img-content&#123;width: 120px;height: 120px;border: 1px solid #000;margin: 20px;float: left;position: relative; z-index: 5;&#125;.img-box&#123;width: 100%;height: 100%;&#125;.img-box img&#123;display: block; width: 100%;height: 100%;&#125;","text":"&emsp;&emsp;最近公司让调研关于webUploader的图片上传中能否压缩，能否实现图片的格式转换，如果能如何实现，经过调研，这个插件可以实现文件的压缩，但是不能实现图片的格式转换，同时在调研过程中，知道了很多新的东西，H5 file API，canvas，等等，所以有了自己写一个文件上传来熟悉这些东西，所以有了本篇文章。 一.做好HTML，CSS样式这里很简单，就是写一个HTML+CSS的文件，让我们的上传看起来像那么回事儿，这里不细说，代码如下： html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;fileUploader&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./index.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"upbox\"&gt; &lt;h1&gt;测试&lt;/h1&gt; &lt;input id=\"uploader\" type=\"file\" multiple=\"multiple\" name=\"file\" accept=\"image/*\"&gt; &lt;/div&gt; &lt;a id=\"test\" href=\"\"&gt;点击选择上传图片&lt;/a&gt; &lt;button type=\"button\" id=\"button\"&gt;上传&lt;/button&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.css1234567.upbox&#123;width: 100%;height: 500px;border: 3px dashed #000;position: relative;&#125;#uploader&#123;display: block;width: 100%;height: 100%;opacity: 0;position: absolute;left: 0;top: 0;cursor: pointer;&#125;h1&#123;position: absolute;left: 45%;top: 40%;&#125;button&#123;width: 100px;height: 50px;float: right;&#125;.img-content&#123;width: 120px;height: 120px;border: 1px solid #000;margin: 20px;float: left;position: relative; z-index: 5;&#125;.img-box&#123;width: 100%;height: 100%;&#125;.img-box img&#123;display: block; width: 100%;height: 100%;&#125; 二.用户多选文件并读取用户选择的文件1.让input实现多文件选择用户在点击input区域后，可以选择文件，H5支持多文件选择，只需要像下面这样写就可以：1&lt;input id=\"uploader\" type=\"file\" multiple=\"multiple\" name=\"file\" accept=\"image/*\"&gt; 在上面代码中，设置multiple可以让input实现文件多选，accept则是允许用户选择什么文件，这里我们要写图片上传，所以接受所有的图片的类型，也为后文的转换上传图片的文件格式奠定基础。 2.利用FileReader对象读取源文件H5的File接口提供了文件的信息以及文件内容的存取的方法。File对象是用户在input元素上选择文件后返回的FileList对象，所以，通过File对象可以获得用户选择的文件。代码如下：123456var uploader=document.querySelectorAll('#uploader')[0];uploader.addEventListener('change',function (event) &#123; var e=event||window.event; var target=e.target; var files=target.files;&#125;); 这里可以获得用户选择的文件，但是因为我们要利用用户选择的源文件生成缩略图，所以需要需要读取的是用户在计算机上存储的源文件，H5提供了FileReader对象，该对象允许web应用程序异步读取存储在用户计算机上的文件（或者元素数据缓冲）内容。 FileReader对象提供了readAsDataURL()方法：readAsDataURL()开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.参数file为将要读取的Blob对象或者File对象.所以拿到用户选择的源文件的代码如下：1234567891011121314151617var filesLen;var uploader=document.querySelectorAll('#uploader')[0];uploader.addEventListener('change',function (event) &#123; var e=event||window.event; var target=e.target; var files=target.files; filesLen=files.length; for(let i=0;i&lt;filesLen;i++)&#123; var reader=new FileReader(); //文件读取结束后要做的事 reader.onload=function (event) &#123; //读取用户选择的文件 var fileURL=event.target.result; &#125; reader.readAsDataURL(files[i]); &#125;&#125;); 因为是读取多个文件，所以需要使用for循环去读取每一个文件（这意味着FileReader一次只读取一个文件，异步读取），这样就拿到了用户选择的图片的源文件，该源文件被读取为base64编码，这位下一步，生成缩略图做了基础。 三.利用canvas生成缩略图H5的canvas提供了drawImage和toDataURL两个方法 1.drawImage()drawImage()方法在画布上绘制图像，画布或视频，同时也能绘制图像的某个部分或者增加减少图像的尺寸。在javascript中有三种语法，分别如下： 在画布上定位图像1context.drawImage(img,x,y); 在画布上定位图像并规定图像的宽度和高度1context.drawImage(img,x,y,width,height); 正是这一点儿让利用canvas压缩图片成为可能（本身生成缩略图也是在更改图片大小） 剪切图像并在画布上定位被剪切部分1context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 以上参数值对应如下： 2.toDataURL()toDataURL()方法回传含有图像和参数设置特定格式的dataURLs，回传的图像解析度为96dpi。同样通过toDataURL()可以方便的将图片转换为base64编码，但是这里需要注意两点： 如果canvas的高度或者宽度为0，则回传的字符串为”data:,”。 如果要求图像类型并非image/png，但是回传的类型却是data:image/png，表示要求的图像类型并不支持。表达式如下：1canvas.toDataURL(type,encoderOptions); type：图片的格式，预设为image/pngencoderOptions：生成的图片的品质，为0~1之间的数字，如果只不在该范围内，则使用默认值，其他会忽略 生成缩略图代码实现基于以上两个canvas方法，可以写出生成缩略图的方法，代码如下：123456789101112131415161718192021222324252627//创建缩略图样式function createThumbnailFromUrl(context,fileURL) &#123; //创建元素 var img=document.createElement('img'), imgBox=document.createElement('div'), imgContent=document.createElement('div'); //添加Class imgBox.classList.add('img-box'); imgContent.classList.add('img-content'); //动态插入创建的元素 context.appendChild(imgContent); imgContent.appendChild(imgBox); imgBox.appendChild(img); //创建canvas重绘缩略图 var canvas=document.createElement('canvas'); var context=canvas.getContext('2d'); // 创建image图片对象 var image=new Image(); image.src=fileURL; image.onload=function () &#123; canvas.width=120; canvas.height=120*(image.height/image.width); context.drawImage(image,0,0,canvas.width,canvas.height); img.src=canvas.toDataURL('image/png',0.5); &#125; &#125; 这里，为了拿到图片对象，也就是拿到要转换的图片，我们新建一个图片对象，然后将图片对象的src赋值为FileReader拿到的FileURL，这样就拿到了用户选择上传的图片，这就将用户选择的文件与canvas联系起来，接下来就进行处理，等图片读取完成后，进行cnavas操作，最后把生成的base64图片编码直接赋值给动态创建的缩略图img，这样就实现了用户在选择完要上传的图片后生成缩略图。 四.将要上传的图片利用canvas进行压缩，改变格式—遇到js中的异步执行canvas压缩，更改图片格式的实现就是上面生成缩略图的方法，但是我在写这里的时候遇到了一个问题，就是javascript中异步执行机制。我在javascript中写了一个函数，代码如下：1234567891011121314151617function changeImg(fileURL) &#123; //创建canvas重绘缩略图 var canvas=document.createElement('canvas'); var context=canvas.getContext('2d'); // 创建image对象 var image=new Image(); //这里把fileURL赋值给src，就可以拿到用户选择的图片，此时可以获取到图片的宽高 image.src=fileURL; image.onload=function () &#123; canvas.width=image.width; canvas.height=image.height; context.drawImage(image,0,0,canvas.width,canvas.height); newFile=canvas.toDataURL('image/png',0.5); //这里的return就是问题的所在 return newFile &#125;&#125; 本来我的想法是通过写一个changeImg函数，在文件读取完成后，进行图片压缩，然后再将转换后的图片利用return返回回来，然后继续操作。但是在执行的时候，发现浏览器一直报错，var newFile=changeImg(newFile)返回的是undefined的。经过询问高手，得知这里遇到了js中异步执行索带来的结果。关于js异步执行机制，我会在接下来做细致研究，并记录，现在说一下通过这个问题知道的一些东西。 什么时候就会出现异步执行机制当在js中出现回调，ajax，FileReader(暂时知道这三个)的时候，就会出现异步执行机制，简单举例：123var a;a=ajax();//这里代表经过ajax执行后返回的值给aconsole.log(a);//undefined 以上代码运行结果并不是ajax返回的值，而是undefined。ajax是 JavaScript和XML，这里我对异步的简单理解就是在代码执行的同时，ajax执行，可以想象，在浏览器中js代码执行的速度与通过ajax返回服务器回传的数据的速度，当ajax返回数据时，浏览器中代码早已执行完成console，所以输入的是undefined，同时这也解释了为什么ajax会存在当ajax调用成功后，再执行一个XXX。所以在这里不能写return newFile，因为image.onload=function(){}也是异步的，我这里想到的办法就是在文件读取完成后，继续创建canvas，转换压缩图片（我感觉这个方法一点儿不好，暂时这么写）。所以正确的代码如下：1234567891011121314151617181920212223242526272829303132333435//input选框change事件，取得文件，创建缩略图uploader.addEventListener('change',function (event) &#123; var e=event||window.event; var target=e.target; files=target.files; filesLen=files.length; for(let i=0;i&lt;filesLen;i++)&#123; var reader=new FileReader(); //文件读取结束后要做的事 reader.onload=function (event) &#123; //读取用户选择的文件 var fileURL=event.target.result; //根据读取的文件创建缩略图 createThumbnailFromUrl(upbox,fileURL); //上传前改变图片的格式 //创建canvas重绘缩略图 var canvas=document.createElement('canvas'); var context=canvas.getContext('2d'); // 创建image对象 var image=new Image(); //这里把fileURL赋值给src，就可以拿到用户选择的图片，此时可以获取到图片的宽高 image.src=fileURL; image.onload=function () &#123; canvas.width=image.width/2; canvas.height=image.width/2*(image.height/image.width); context.drawImage(image,0,0,canvas.width,canvas.height); newURL=canvas.toDataURL('image/jpeg',0.5); var base=newURL.substr(23); newFile=atob(base); &#125; &#125; reader.readAsDataURL(files[i]); filesArray.push(newURL); &#125;&#125;,false); 上面的代码实现了将经过转换的图片的base64编码放入一个数组中，将这些代码传给后台。这里有一点，本身base64可以利用javascript的window.atob()实现base64的转码，但是简单利用该函数进行转码不能转回图片，还需要blob对象中的一些东西，关于这个对象我并没有深入研究，只是知道，对于该对象的研究我会在接下来继续研究。后台可以解析base64，所以直接把base64传给后台也可以，关于base64转码的实现可以参考稀土掘金中的文章@用Canvas技术压缩要上传的图片。 五.利用XMLHttpRequest,FormData实现文件上传1.FormData对象利用FormData对象可以创建一系列键值对来模拟一个完整的表单，然后再使用XMLHttpRequest发送这个表单，这样就不用像传统的表单那样写form。所以在新建一个FormData对象：1var data=new FormData(); 然后就可以使用append()方法向该对象里添加字段，形成可以发送给后台的键值对。 2.XMLHttpRequest对象通过XMLHttpRequest可以很容易取回URL上的数据资源，可以取回的数据不仅仅是XML，除了支持HTTP还支持file，ftp协议。通过下列代码可以获得一个XMLHttpRequest()实例。 然后利用open()初始化请求。123var xhr=new XMLHttpRequest();xhr.open('post','uploader.php',true);xhr.send(data); 3.open方法open可以写入的参数如下：1234567void open( DOMString method, DOMString url, optional boolean async, optional DOMString user, optional DOMString password); method：请求所使用的HTTP方法：例如’GET’，’POST’，’PUT’，’DELETE’等，但是如果下个参数是非HTTP(S)的URL，则忽略该参数。 url：该请求所要访问的URL async：一个可选的布尔值参数，默认为true,意味着是否执行异步操作，如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据。如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者。这个值必须是true,如果multipart 属性是true，否则将会出现一个意外。 user：用户名,可选参数,为授权使用;默认参数为空string. password：密码,可选参数,为授权使用;默认参数为空string.4.send()方法发送请求. 如果该请求是异步模式(默认),该方法会立刻返回. 相反,如果请求是同步模式,则直到请求的响应完全接受以后,该方法才会返回.综合以上，简单的一个上传图片代码实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//创建缩略图样式function createThumbnailFromUrl(context,fileURL) &#123; //创建元素 var img=document.createElement('img'), imgBox=document.createElement('div'), imgContent=document.createElement('div'); //添加Class imgBox.classList.add('img-box'); imgContent.classList.add('img-content'); //动态插入创建的元素 context.appendChild(imgContent); imgContent.appendChild(imgBox); imgBox.appendChild(img); //创建canvas重绘缩略图 var canvas=document.createElement('canvas'); var context=canvas.getContext('2d'); // 创建image对象 var image=new Image(); image.src=fileURL; image.onload=function () &#123; canvas.width=120; canvas.height=120*(image.height/image.width); context.drawImage(image,0,0,canvas.width,canvas.height); img.src=canvas.toDataURL('image/png',0.5); &#125; &#125;window.addEventListener('load',function () &#123; var uploader=document.querySelectorAll('#uploader')[0]; var button=document.querySelectorAll('#button')[0]; var upbox=document.querySelectorAll('.upbox')[0]; var files,filesLen,newFileURL,newFile; var filesArray=[],newURL; var test=document.querySelectorAll('#test')[0]; //input选框change事件，取得文件，创建缩略图 uploader.addEventListener('change',function (event) &#123; var e=event||window.event; var target=e.target; files=target.files; filesLen=files.length; for(let i=0;i&lt;filesLen;i++)&#123; var reader=new FileReader(); //文件读取结束后要做的事 reader.onload=function (event) &#123; //读取用户选择的文件 var fileURL=event.target.result; //根据读取的文件创建缩略图 createThumbnailFromUrl(upbox,fileURL); //上传前改变图片的格式 //创建canvas重绘缩略图 var canvas=document.createElement('canvas'); var context=canvas.getContext('2d'); // 创建image对象 var image=new Image();//这里把fileURL赋值给src，就可以拿到用户选择的图片，此时可以获取到图片的宽高 image.src=fileURL; image.onload=function () &#123; canvas.width=image.width/2; canvas.height=image.width/2*(image.height/image.width); context.drawImage(image,0,0,canvas.width,canvas.height); newURL=canvas.toDataURL('image/jpeg',0.5); var base=newURL.substr(23); newFile=atob(base); &#125; &#125; reader.readAsDataURL(files[i]); filesArray.push(newURL); &#125; &#125;,false); //button按钮点击上传 button.addEventListener('click',function () &#123; if(filesLen.length!=0)&#123; var data=new FormData(); var i=0; //将所有的经过转码后的base64组成的数组传给后台 while(i&lt;filesLen)&#123; data.append('file'+i,filesArray[i]); i++; &#125; var xhr = new XMLHttpRequest(); xhr.open('post','uploader.php',true); xhr.onreadystatechange=function () &#123; if(xhr.readyState==4)&#123; console.log(xhr.responseText); &#125; &#125;; xhr.send(data); &#125; &#125;)&#125;,false);","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}],"tags":[{"name":"H5 file，canvas","slug":"H5-file，canvas","permalink":"http://mrzhang123.github.io/tags/H5-file，canvas/"}],"keywords":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}]},{"title":"H5焦点管理---tabindex与document.activeElement","slug":"activeElement","date":"2016-03-26T02:20:56.000Z","updated":"2016-08-02T16:38:41.427Z","comments":true,"path":"2016/03/26/activeElement/","link":"","permalink":"http://mrzhang123.github.io/2016/03/26/activeElement/","excerpt":"&emsp;&emsp;周四下午测试人员提出BUG，说我写的那个类支付宝密码框在按下Tab键时候无法像原生的form表单中的input那样被激活，当时的第一反应是，我的密码框原本就是用div模拟的，怎么可能想form表单一样在Tab键时候激活呢。但是当我打开支付宝官网，按下tab键后，密码框可以被激活，这激起了我的好奇心，也就有了后来对tabindex和document.activeElement的发现。废话不多说，进入正题。 HTML tabindex属tabindex的设置&emsp;&emsp;当Tab键用于导航时，tabindex属性规定元素的tab键控制次序，其中tabindex的值为阿拉伯数字，默认情况下越靠前的元素该值越小，所以我们可以通过人为改变tabindex的值来改变按下Tab键后可以被激活元素的激活顺序，只需要做如下设置：1234&lt;input type=\"text\" tabindex=\"1\"&gt;&lt;input type=\"text\" tabindex=\"2\"&gt;&lt;input type=\"text\" tabindex=\"4\"&gt;&lt;input type=\"text\" tabindex=\"3\"&gt;","text":"&emsp;&emsp;周四下午测试人员提出BUG，说我写的那个类支付宝密码框在按下Tab键时候无法像原生的form表单中的input那样被激活，当时的第一反应是，我的密码框原本就是用div模拟的，怎么可能想form表单一样在Tab键时候激活呢。但是当我打开支付宝官网，按下tab键后，密码框可以被激活，这激起了我的好奇心，也就有了后来对tabindex和document.activeElement的发现。废话不多说，进入正题。 HTML tabindex属tabindex的设置&emsp;&emsp;当Tab键用于导航时，tabindex属性规定元素的tab键控制次序，其中tabindex的值为阿拉伯数字，默认情况下越靠前的元素该值越小，所以我们可以通过人为改变tabindex的值来改变按下Tab键后可以被激活元素的激活顺序，只需要做如下设置：1234&lt;input type=\"text\" tabindex=\"1\"&gt;&lt;input type=\"text\" tabindex=\"2\"&gt;&lt;input type=\"text\" tabindex=\"4\"&gt;&lt;input type=\"text\" tabindex=\"3\"&gt; &emsp;&emsp;以上代码在浏览器中按下Tab键激活顺序就是它们在HTML代码中的顺序，但是我在这里设置第三个input的tabindex比第四个的大，所以按下Tab键后，第四个input框的激活在第三个之前。 注意&emsp;&emsp;1.前面说过tabindex的值越小，越被早激活，但是tabIndex的值要0~32767之间。&emsp;&emsp;2.如果把tabindex值设置为负值（比如设置为tabindex=-1），则按下Tab键不会激活该元素，但是该元素的focus和blur事件仍然启动。&emsp;&emsp;3.如果把tabindex设置为0，则带0值tabIndex的元素根据源代码（或默认页面行为）进行排序。&emsp;&emsp;4.如果页面中出现多个tabindex值相同的元素，则浏览器会把这些元素的tabindex值看做0。 为div与span设置tabindex&emsp;&emsp;默认情况下按下Tab键可以被选中或者激活的有a,area,button,input,object,select,textarea，但是在现代浏览器和IE9+中给div和span设置tabindex属性也可以被选中，在chrome中，被选中的元素会出现淡蓝色的边框。 H5焦点管理document.activeElement&emsp;&emsp;H5添加了辅助管理DOM焦点的document.activeElemnt属性，这个属性始终会引用DOM中当前获得了焦点的元素。元素获取焦点的方式有页面加载，用户输入（通常是通过按Tab键）和代码中调用focus()方法。&emsp;&emsp;默认情况下，文档刚刚加载完，document.activeElement中保存的是document.body元素的引用。文档加载期间，document.activeElement的值为null。另外顺带提一句，判断是否获得焦点可以使用hasFocus()。&emsp;&emsp;利用该属性，就可以知道当前哪个元素被Tab键激活，进而就可以获取到被激活元素的各类属性，比如可以在按下Tab键时候去输出当前被激活元素的class属性。代码如下：123456789$(function()&#123; var $input=$('input'); $input.on('keydown',function(e)&#123; var event=e||window.event; if(event.keyCode==9)&#123; console.log(document.activeElement.attr('class')); &#125; &#125;);&#125;); 总结&emsp;&emsp;基于以上两点，通过判断当前被激活的元素的class，就实现了让模拟的密码输入框有和原生的input一样在按下Tab键被激活。","categories":[{"name":"HTML","slug":"HTML","permalink":"http://mrzhang123.github.io/categories/HTML/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://mrzhang123.github.io/tags/HTML5/"}],"keywords":[{"name":"HTML","slug":"HTML","permalink":"http://mrzhang123.github.io/categories/HTML/"}]},{"title":"H5 Canvas实现图片格式的转换","slug":"tec-2","date":"2016-03-22T15:46:18.000Z","updated":"2016-08-02T16:39:18.851Z","comments":true,"path":"2016/03/22/tec-2/","link":"","permalink":"http://mrzhang123.github.io/2016/03/22/tec-2/","excerpt":"&emsp;&emsp;今天早上到公司，看到CTO要求调查关于前端如何实现图片格式转换，自己上网找了下关于canvas如何实现图片格式转换，其实还是蛮简单的，但是因为网上的教程着实写的简单，而且都一样，我也是醉了，所以写下这篇博客，以记录今天的调查结果。 使用Javasript将图片写入画布1234567function convertImageToCanvas(image) &#123; var canvas = document.createElement(\"canvas\"); canvas.width = image.width; canvas.height = image.height; canvas.getContext(\"2d\").drawImage(image, 0, 0); return canvas;&#125;","text":"&emsp;&emsp;今天早上到公司，看到CTO要求调查关于前端如何实现图片格式转换，自己上网找了下关于canvas如何实现图片格式转换，其实还是蛮简单的，但是因为网上的教程着实写的简单，而且都一样，我也是醉了，所以写下这篇博客，以记录今天的调查结果。 使用Javasript将图片写入画布1234567function convertImageToCanvas(image) &#123; var canvas = document.createElement(\"canvas\"); canvas.width = image.width; canvas.height = image.height; canvas.getContext(\"2d\").drawImage(image, 0, 0); return canvas;&#125; 用JavaScript将画布保持成图片格式123456function convertCanvasToImage(canvas) &#123; var image = new Image(); //这里的image后面可以写png，jpeg，但是不能写jpg，写了不会转换的 image.src = canvas.toDataURL(\"image/jpeg\"); return image;&#125; 调用函数实现转换&emsp;&emsp;函数convertImageToCanvas需要传入一个image对象，这个对象需要我们手动去获取，例如，可以在html页面中写入img标签并引入图片，然后利用js获取img对象，将img对象传入该函数，即可获得返回的canvas对象，再将该canvas对象传入函数convertCanvasToImage即可获得返回的image，但是，这里获得的是base64的编码的图片，本身绘制在canvas画布上的图片右键保存还是png图，所以，要想获得转换后的图片，可以利用a标签在href中写入base64编码获得，点击a标签可以跳转到转换后的图片。关于如将base64编码的图片解码成图片，因为今天下午事儿多，没顾上研究，有时间，研究一下。实现代码如下：1234567var img=document.getElementById('img');var body=document.getElementById('body');var canvas=convertImageToCanvas(img);convertCanvasToImage(canvas);var link=document.createElement('a');body.appendChild(link);link.innerHTML('跳转图片'); &emsp;&emsp;以上代码可以在点击link链接后得到转换后的图片，今天就研究到这些，以后有时间再继续研究完善。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://mrzhang123.github.io/tags/canvas/"}],"keywords":[{"name":"Javascript","slug":"Javascript","permalink":"http://mrzhang123.github.io/categories/Javascript/"}]},{"title":"jquery插件开发","slug":"tec-1","date":"2016-03-21T15:04:53.000Z","updated":"2016-08-02T16:39:45.492Z","comments":true,"path":"2016/03/21/tec-1/","link":"","permalink":"http://mrzhang123.github.io/2016/03/21/tec-1/","excerpt":"由于公司需要写一个功能，而公司的中使用的框架是jquery，所以想到了开发jquery框架。 1.jQuery插件开发方式jQuery插件开发方式主要有三种：通过$.extend（），通过$.fn向jQuery添加新的方法，通过$weight（）应用jQueryUI的部件工厂方式创建 2.插件中的this在插件名字定义的这个函数内部，this指代的是在调用该插件时，用jQuery选择器选中的元素。这里的this已经是jQuery元素，无需再用美元符包装。 3.jQuery链式调用jQuery支持链式调用，要让插件不打破这个链式调用，只需要return一下，实例如下12345678$.fn.myPlugin = function()&#123; //这里面this指的是jquery选中的元素 this.css('color','red'); return this.each(function()&#123; //对每个元素进行操作 $(this).append(' '+$(this).attr('href')); &#125;)&#125;","text":"由于公司需要写一个功能，而公司的中使用的框架是jquery，所以想到了开发jquery框架。 1.jQuery插件开发方式jQuery插件开发方式主要有三种：通过$.extend（），通过$.fn向jQuery添加新的方法，通过$weight（）应用jQueryUI的部件工厂方式创建 2.插件中的this在插件名字定义的这个函数内部，this指代的是在调用该插件时，用jQuery选择器选中的元素。这里的this已经是jQuery元素，无需再用美元符包装。 3.jQuery链式调用jQuery支持链式调用，要让插件不打破这个链式调用，只需要return一下，实例如下12345678$.fn.myPlugin = function()&#123; //这里面this指的是jquery选中的元素 this.css('color','red'); return this.each(function()&#123; //对每个元素进行操作 $(this).append(' '+$(this).attr('href')); &#125;)&#125; 4.让插件接受参数在处理插件参数的接收上，通常用jQuery的extend方法，当给extend传递单个对象时，这个对象会合并到jquery身上，直接可以调用，当给extend方法传递一个以上参数时，它会将所有参数对象合并到1234567891011$.fn.myPlugin = function()&#123; var defaults = &#123; 'color':'red', 'fontSize':'12px' &#125;; var setting = $.extend(defaults,options); return this.css(&#123; 'color':setting.color, 'fontSize':setting.fontSize &#125;);&#125;","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://mrzhang123.github.io/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://mrzhang123.github.io/tags/jQuery/"}],"keywords":[{"name":"jQuery","slug":"jQuery","permalink":"http://mrzhang123.github.io/categories/jQuery/"}]},{"title":"一些想法","slug":"article-2","date":"2016-03-21T13:37:42.000Z","updated":"2016-07-14T03:05:02.952Z","comments":true,"path":"2016/03/21/article-2/","link":"","permalink":"http://mrzhang123.github.io/2016/03/21/article-2/","excerpt":"&emsp;&emsp;今天下班比较早，本来想的要看书呢，结果都走了，所以我也就下班了，回来时候回顾自己的一天，感觉今天什么都没学下，瞬间觉得自己今天没多少收获，本来早晨时候任务很多，但是很多任务都不是很明确，让我很迷茫，不知道该怎么弄，后来问了问陈哥，才发现这些任务好几个都是能完成一半，自己的强迫症瞬间犯了，我不喜欢我的任务栏中有那么多任务，但是又完成不了，着实让我觉得难受啊！","text":"&emsp;&emsp;今天下班比较早，本来想的要看书呢，结果都走了，所以我也就下班了，回来时候回顾自己的一天，感觉今天什么都没学下，瞬间觉得自己今天没多少收获，本来早晨时候任务很多，但是很多任务都不是很明确，让我很迷茫，不知道该怎么弄，后来问了问陈哥，才发现这些任务好几个都是能完成一半，自己的强迫症瞬间犯了，我不喜欢我的任务栏中有那么多任务，但是又完成不了，着实让我觉得难受啊！&emsp;&emsp;回想起自己的工作，来到工作这半年多来，感觉并没多少成长，这里我所说的成长指的是并没有从无到有学会一个自己曾经从没接触过的东西，有时候会觉得每天就是改改样式，改改页面，前端和后台的交互我都不需要写这样好么？说实话，自己也不是说改那些就改的很好，总是很粗心，陈哥说我眼高手低，可能怎得是这样，自己以后一定要改正。去年元旦的时候，给自己定下要在2016年多读书，要每天跑步，要学习掌握前端框架，但是现在都快3月底了，貌似只做到了每天早晨跑步，其他都没有，前几天没事儿干，一直都在看《javascript高级程序设计》，感觉收获蛮多的，讲的javascript非常细。公司的要求支持IE9+，所以我感觉用原生js是可以用的。关于框架，有时候觉得可能是自己知道的太多了，学什么犹犹豫豫的，这样下去不太好，这样犹豫下去什么都学不会，所以要选一个自己感兴趣的去钻研。&emsp;&emsp;晚上回来的时候听说同学跳槽涨工资了，自己觉得可能心里有些不平衡，所以更加心烦，开始考虑到底要不要换工作，什么时候需要换工作，反正各种跟跳槽有关的想法出现在我的脑海中，感觉自己淡定不了了，从小到大一直都是这样，这样真心不好，自己的抗干扰能力太差了，外界一点儿风吹草动自己就淡定不下来，就觉得应该怎么样怎么样，这着实不应该，无论别人如何，自己做好自己就行，干嘛非得想别人怎么样怎么样呢。不过回想起来，确实是自己也出问题了，每到周六日就想到玩儿玩儿玩儿，这么玩儿下去，必然学习的机会少，所以在这一点上以后一定要注意点儿，毕竟公司其实也学不到你想学的东西，全靠自己，关于每天的时间规划，应该要仔细点儿，有时候真是觉得一天不知道干了些什么，反正一天就过去了。心若冰清，天塌不惊，淡定…&emsp;&emsp;本来是弄个博客要记录些技术，成日记本了，不管怎么说，加油吧！","categories":[{"name":"生活","slug":"生活","permalink":"http://mrzhang123.github.io/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://mrzhang123.github.io/tags/生活/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://mrzhang123.github.io/categories/生活/"}]},{"title":"第一篇文章","slug":"article-1","date":"2016-03-20T03:25:38.000Z","updated":"2016-07-14T03:05:46.646Z","comments":true,"path":"2016/03/20/article-1/","link":"","permalink":"http://mrzhang123.github.io/2016/03/20/article-1/","excerpt":"&emsp;&emsp;这个星期前两天因为要发版，所以在星期一二很忙，真心累的厉害，因为要发版。终于在周四晚上发版了，大家都很拼，真心觉得公司很有前途。周四时候，我突然想起来要弄个博客，所以自己查了查，找到github与hexo，hexo生成静态页面，github提供免费服务，所以二话不说，直接闹起，在这些天的研究中，感受到了github的强大，在那上面弄项目真心感觉很爽。同时也觉得nodejs真的是非常强大，各种插件，各种玩儿。","text":"&emsp;&emsp;这个星期前两天因为要发版，所以在星期一二很忙，真心累的厉害，因为要发版。终于在周四晚上发版了，大家都很拼，真心觉得公司很有前途。周四时候，我突然想起来要弄个博客，所以自己查了查，找到github与hexo，hexo生成静态页面，github提供免费服务，所以二话不说，直接闹起，在这些天的研究中，感受到了github的强大，在那上面弄项目真心感觉很爽。同时也觉得nodejs真的是非常强大，各种插件，各种玩儿。&emsp;&emsp;hexo写博客支持markdown格式，第一次接触markdown是在上传github上面的第一个项目时候写read.md时候开始写的，挺好玩儿的，我的第一个github上面的项目是要求我做一个类支付宝的密码输入，本来自己找的插件，但是发现bug太多，所以直接自己写了，写的过程中，发现也不难，开始慢慢的接触jquery插件如何写，开始接触，现在项目已经上传github，网址为 https://github.com/MrZhang123/jquery.pwd ，起初传上去是为了让别人看看，改改，因为有缺陷还，不过貌似没人看，但是也挺开心，自己弄得第一个github项目。&emsp;&emsp;玩儿hexo，github，git是必不可少的，因为公司用的git，有客户端smartgit，所以在公司上传项目很简答，但是，我可能就是一个爱折腾的人，我在自己的电脑上，装的是命令行的git，喜欢命令，感觉蛮帅气（有点儿装了，嘿嘿），用这个我可以学习一下git，现在用git的人越来越多，我很庆幸，公司用的是git而不是svn，因为经常见网上有文章写git用法什么的，说明git技能还是蛮重要的，所以我觉得我有必要学习下。顺便提一句，最近准备买电脑了，买了电脑后准备上linux+win双系统，开始慢慢熟悉liux，慢慢学着用命令行。&emsp;&emsp;这是我的第一篇正式文章，记录下来，以作纪念。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrzhang123.github.io/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://mrzhang123.github.io/tags/生活/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://mrzhang123.github.io/categories/生活/"}]}]}